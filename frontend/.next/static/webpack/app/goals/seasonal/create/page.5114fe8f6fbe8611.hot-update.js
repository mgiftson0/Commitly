"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/goals/seasonal/create/page",{

/***/ "(app-pages-browser)/./lib/group-goals.ts":
/*!****************************!*\
  !*** ./lib/group-goals.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   acceptGroupGoalInvitation: () => (/* binding */ acceptGroupGoalInvitation),\n/* harmony export */   assignActivity: () => (/* binding */ assignActivity),\n/* harmony export */   canUpdateGroupGoalProgress: () => (/* binding */ canUpdateGroupGoalProgress),\n/* harmony export */   canUserEditActivity: () => (/* binding */ canUserEditActivity),\n/* harmony export */   canUserUpdateActivity: () => (/* binding */ canUserUpdateActivity),\n/* harmony export */   checkAllMembersResponded: () => (/* binding */ checkAllMembersResponded),\n/* harmony export */   completeActivity: () => (/* binding */ completeActivity),\n/* harmony export */   createGroupGoal: () => (/* binding */ createGroupGoal),\n/* harmony export */   declineGroupGoalInvitation: () => (/* binding */ declineGroupGoalInvitation),\n/* harmony export */   deleteGroupGoal: () => (/* binding */ deleteGroupGoal),\n/* harmony export */   getActivityCompletions: () => (/* binding */ getActivityCompletions),\n/* harmony export */   getActivityProgress: () => (/* binding */ getActivityProgress),\n/* harmony export */   getGroupGoalDetails: () => (/* binding */ getGroupGoalDetails),\n/* harmony export */   getGroupGoalMembers: () => (/* binding */ getGroupGoalMembers),\n/* harmony export */   getGroupGoalProgress: () => (/* binding */ getGroupGoalProgress),\n/* harmony export */   getPendingInvitations: () => (/* binding */ getPendingInvitations),\n/* harmony export */   isGroupGoalAdmin: () => (/* binding */ isGroupGoalAdmin),\n/* harmony export */   uncompleteActivity: () => (/* binding */ uncompleteActivity),\n/* harmony export */   updateActivityAssignment: () => (/* binding */ updateActivityAssignment),\n/* harmony export */   updateGroupGoal: () => (/* binding */ updateGroupGoal)\n/* harmony export */ });\n/* harmony import */ var _supabase_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase-client */ \"(app-pages-browser)/./lib/supabase-client.ts\");\n/**\n * Group Goals Service\n * Handles all group goal operations including invitations, member management, and activity assignments\n */ \n/**\n * Create a group goal with initial members\n */ async function createGroupGoal(goalData, memberIds) {\n    try {\n        const { data: { user } } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) throw new Error('Not authenticated');\n        // Create the goal\n        const { data: goal, error: goalError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goals').insert({\n            ...goalData,\n            user_id: user.id,\n            is_group_goal: true,\n            group_goal_status: 'pending'\n        }).select().single();\n        if (goalError) throw goalError;\n        // Add owner as accepted member\n        const { error: memberError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').insert({\n            goal_id: goal.id,\n            user_id: user.id,\n            role: 'owner',\n            status: 'accepted',\n            can_edit: true\n        });\n        if (memberError) {\n            console.error('Error adding owner as member:', memberError);\n        }\n        // Send invitations to members\n        const invitations = memberIds.map((memberId)=>({\n                goal_id: goal.id,\n                inviter_id: user.id,\n                invitee_id: memberId,\n                status: 'pending',\n                message: \"Join our group goal: \".concat(goalData.title)\n            }));\n        const { error: inviteError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_invitations').insert(invitations);\n        if (inviteError) throw inviteError;\n        // Create notifications for invitees\n        const { data: profile } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('profiles').select('first_name, last_name, username').eq('id', user.id).single();\n        const userName = profile ? \"\".concat(profile.first_name, \" \").concat(profile.last_name).trim() || profile.username : 'Someone';\n        // Insert notifications with proper structure for Commitly\n        const notifications = memberIds.map((memberId)=>({\n                user_id: memberId,\n                type: 'accountability_request',\n                title: 'Group Goal Invitation ðŸŽ¯',\n                message: \"\".concat(userName, ' invited you to join the group goal: \"').concat(goal.title, '\"'),\n                data: {\n                    goal_id: goal.id,\n                    inviter_id: user.id,\n                    invitation_type: 'group_goal',\n                    action_required: true\n                },\n                read: false\n            }));\n        const { error: notifError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('notifications').insert(notifications);\n        if (notifError) console.error('Notification error:', notifError);\n        return {\n            goal,\n            success: true\n        };\n    } catch (error) {\n        console.error('Error creating group goal:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Get pending invitations for current user\n */ async function getPendingInvitations() {\n    try {\n        const { data: { user } } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) throw new Error('Not authenticated');\n        const { data, error } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_invitations').select(\"\\n        *,\\n        goal:goals(title, description, category),\\n        inviter:profiles!group_goal_invitations_inviter_id_fkey(\\n          first_name, last_name, username, profile_picture_url\\n        )\\n      \").eq('invitee_id', user.id).eq('status', 'pending').order('created_at', {\n            ascending: false\n        });\n        if (error) throw error;\n        return {\n            data,\n            success: true\n        };\n    } catch (error) {\n        console.error('Error fetching invitations:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Accept group goal invitation\n */ async function acceptGroupGoalInvitation(invitationId) {\n    try {\n        const { data: { user } } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) throw new Error('Not authenticated');\n        // Get invitation details\n        const { data: invitation } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_invitations').select('goal_id, invitee_id').eq('id', invitationId).single();\n        if (!invitation) throw new Error('Invitation not found');\n        // Update invitation status\n        const { error: inviteError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_invitations').update({\n            status: 'accepted',\n            responded_at: new Date().toISOString()\n        }).eq('id', invitationId).eq('invitee_id', user.id);\n        if (inviteError) throw inviteError;\n        // Add user as accepted member\n        const { error: memberError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').upsert({\n            goal_id: invitation.goal_id,\n            user_id: user.id,\n            role: 'member',\n            status: 'accepted',\n            can_edit: false\n        });\n        if (memberError) throw memberError;\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error('Error accepting invitation:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Decline group goal invitation\n */ async function declineGroupGoalInvitation(invitationId) {\n    try {\n        const { data: { user } } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) throw new Error('Not authenticated');\n        // Get invitation details\n        const { data: invitation } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_invitations').select('goal_id, invitee_id').eq('id', invitationId).single();\n        if (!invitation) throw new Error('Invitation not found');\n        // Update invitation status\n        const { error: inviteError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_invitations').update({\n            status: 'declined',\n            responded_at: new Date().toISOString()\n        }).eq('id', invitationId).eq('invitee_id', user.id);\n        if (inviteError) throw inviteError;\n        // Add user as declined member (triggers activity reassignment)\n        const { error: memberError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').upsert({\n            goal_id: invitation.goal_id,\n            user_id: user.id,\n            role: 'member',\n            status: 'declined',\n            can_edit: false\n        });\n        if (memberError) throw memberError;\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error('Error declining invitation:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Get group goal members\n */ async function getGroupGoalMembers(goalId) {\n    try {\n        const { data, error } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').select(\"\\n        *,\\n        profile:profiles(first_name, last_name, username, profile_picture_url)\\n      \").eq('goal_id', goalId).order('created_at', {\n            ascending: true\n        });\n        if (error) throw error;\n        return {\n            data,\n            success: true\n        };\n    } catch (error) {\n        console.error('Error fetching members:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Assign activity to user(s) (deprecated - use updateActivityAssignment)\n */ async function assignActivity(activityId, assignment) {\n    return updateActivityAssignment(activityId, assignment);\n}\n/**\n * Complete activity for current user\n */ async function completeActivity(activityId, goalId, notes) {\n    try {\n        const { data: { user } } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) throw new Error('Not authenticated');\n        // Check if activity is assigned to this user\n        const { data: activity } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goal_activities').select('assigned_to, assigned_to_all, assigned_members, title').eq('id', activityId).single();\n        if (!activity) throw new Error('Activity not found');\n        // Verify user can complete this activity\n        const canComplete = activity.assigned_to_all || activity.assigned_to === user.id || activity.assigned_members && activity.assigned_members.includes(user.id);\n        if (!canComplete) {\n            throw new Error('You are not assigned to this activity');\n        }\n        // Check if already completed by this user\n        const { data: existingCompletion } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('activity_completions').select('id').eq('activity_id', activityId).eq('user_id', user.id).single();\n        if (existingCompletion) {\n            throw new Error('Activity already completed by you');\n        }\n        // Insert completion record\n        const { error } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('activity_completions').insert({\n            activity_id: activityId,\n            user_id: user.id,\n            goal_id: goalId,\n            notes\n        });\n        if (error) throw error;\n        // Notify other group members\n        const { data: members } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').select('user_id').eq('goal_id', goalId).eq('status', 'accepted').neq('user_id', user.id);\n        if (members && members.length > 0) {\n            const { data: userProfile } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('profiles').select('first_name, last_name, username').eq('id', user.id).single();\n            const userName = userProfile ? \"\".concat(userProfile.first_name, \" \").concat(userProfile.last_name).trim() || userProfile.username : 'Someone';\n            const notifications = members.map((member)=>({\n                    user_id: member.user_id,\n                    type: 'activity_completed',\n                    title: 'Activity Completed! ðŸŽ‰',\n                    message: \"\".concat(userName, ' completed: \"').concat(activity.title, '\"'),\n                    data: {\n                        activity_id: activityId,\n                        goal_id: goalId,\n                        completed_by: user.id,\n                        completed_by_name: userName\n                    },\n                    read: false\n                }));\n            await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('notifications').insert(notifications);\n        }\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error('Error completing activity:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Uncomplete activity for current user (remove completion)\n */ async function uncompleteActivity(activityId, goalId) {\n    try {\n        const { data: { user } } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) throw new Error('Not authenticated');\n        // Check if user can edit this activity\n        const canEdit = await canUserEditActivity(activityId, user.id);\n        if (!canEdit) {\n            throw new Error('You cannot uncomplete this activity');\n        }\n        // Remove completion record\n        const { error } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('activity_completions').delete().eq('activity_id', activityId).eq('user_id', user.id);\n        if (error) throw error;\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error('Error uncompleting activity:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Get activity completion status for group goal\n */ async function getActivityCompletions(activityId) {\n    try {\n        const { data, error } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('activity_completions').select(\"\\n        *,\\n        user:profiles(first_name, last_name, username, profile_picture_url)\\n      \").eq('activity_id', activityId).order('completed_at', {\n            ascending: false\n        });\n        if (error) throw error;\n        return {\n            data,\n            success: true\n        };\n    } catch (error) {\n        console.error('Error fetching completions:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Check if user can update activity (deprecated - use canUserEditActivity)\n */ async function canUserUpdateActivity(activityId, userId) {\n    return canUserEditActivity(activityId, userId);\n}\n/**\n * Check if user is admin (owner) of a group goal\n */ async function isGroupGoalAdmin(goalId, userId) {\n    try {\n        // Check if user is the goal owner\n        const { data: goal } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goals').select('user_id, is_group_goal').eq('id', goalId).single();\n        if (!goal) return false;\n        // For group goals, check if user is the owner\n        if (goal.is_group_goal) {\n            return goal.user_id === userId;\n        }\n        // For regular goals, only owner can manage\n        return goal.user_id === userId;\n    } catch (error) {\n        console.error('Error checking admin permissions:', error);\n        return false;\n    }\n}\n/**\n * Check if user can edit a specific activity\n */ async function canUserEditActivity(activityId, userId) {\n    try {\n        const { data: activity } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goal_activities').select('assigned_to, assigned_to_all, assigned_members, goal_id').eq('id', activityId).single();\n        if (!activity) return false;\n        // Check if user is goal admin first\n        const isAdmin = await isGroupGoalAdmin(activity.goal_id, userId);\n        if (isAdmin) return true;\n        // Check if activity is assigned to this user\n        if (activity.assigned_to_all) return true;\n        if (activity.assigned_to === userId) return true;\n        if (activity.assigned_members && activity.assigned_members.includes(userId)) return true;\n        return false;\n    } catch (error) {\n        console.error('Error checking activity edit permissions:', error);\n        return false;\n    }\n}\n/**\n * Get detailed group goal with members and activities\n */ async function getGroupGoalDetails(goalId) {\n    try {\n        // Get goal details\n        const { data: goal, error: goalError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goals').select('*').eq('id', goalId).single();\n        if (goalError) throw goalError;\n        // Get members\n        const { data: members, error: membersError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').select(\"\\n        *,\\n        profile:profiles(first_name, last_name, username, profile_picture_url)\\n      \").eq('goal_id', goalId).order('created_at', {\n            ascending: true\n        });\n        if (membersError) throw membersError;\n        // Get activities with assignments\n        const { data: activities, error: activitiesError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goal_activities').select('*').eq('goal_id', goalId).order('order_index', {\n            ascending: true\n        });\n        if (activitiesError) throw activitiesError;\n        // Get activity completions\n        const { data: completions, error: completionsError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('activity_completions').select(\"\\n        *,\\n        user:profiles(first_name, last_name, username, profile_picture_url)\\n      \").eq('goal_id', goalId).order('completed_at', {\n            ascending: false\n        });\n        if (completionsError) throw completionsError;\n        return {\n            data: {\n                goal,\n                members: members || [],\n                activities: activities || [],\n                completions: completions || []\n            },\n            success: true\n        };\n    } catch (error) {\n        console.error('Error fetching group goal details:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Update activity assignment (admin only)\n */ async function updateActivityAssignment(activityId, assignment) {\n    try {\n        var _assignment_assignedMembers;\n        const { data: { user } } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) throw new Error('Not authenticated');\n        // Get activity to check permissions\n        const { data: activity } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goal_activities').select('goal_id').eq('id', activityId).single();\n        if (!activity) throw new Error('Activity not found');\n        // Check if user is admin\n        const isAdmin = await isGroupGoalAdmin(activity.goal_id, user.id);\n        if (!isAdmin) {\n            throw new Error('Only admins can update activity assignments');\n        }\n        const { error } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goal_activities').update({\n            assigned_to: assignment.assignedTo || null,\n            assigned_to_all: assignment.assignedToAll,\n            assigned_members: assignment.assignedMembers || null,\n            activity_type: assignment.assignedToAll ? 'collaborative' : ((_assignment_assignedMembers = assignment.assignedMembers) === null || _assignment_assignedMembers === void 0 ? void 0 : _assignment_assignedMembers.length) ? 'multi_member' : 'individual'\n        }).eq('id', activityId);\n        if (error) throw error;\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error('Error updating activity assignment:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Delete group goal (admin only)\n */ async function deleteGroupGoal(goalId) {\n    try {\n        const { data: { user } } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) throw new Error('Not authenticated');\n        // Check if user is admin\n        const isAdmin = await isGroupGoalAdmin(goalId, user.id);\n        if (!isAdmin) {\n            throw new Error('Only the goal admin can delete this goal');\n        }\n        // Get goal details for notifications\n        const { data: goal } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goals').select('title').eq('id', goalId).single();\n        // Get all members to notify them\n        const { data: members } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').select('user_id, profile:profiles(first_name, last_name)').eq('goal_id', goalId).eq('status', 'accepted').neq('user_id', user.id) // Exclude the admin\n        ;\n        // Delete the goal (cascade will handle related records)\n        const { error } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goals').delete().eq('id', goalId);\n        if (error) throw error;\n        // Notify all members about goal deletion\n        if (members && members.length > 0 && goal) {\n            const { data: adminProfile } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('profiles').select('first_name, last_name, username').eq('id', user.id).single();\n            const adminName = adminProfile ? \"\".concat(adminProfile.first_name, \" \").concat(adminProfile.last_name).trim() || adminProfile.username : 'Admin';\n            const notifications = members.map((member)=>({\n                    user_id: member.user_id,\n                    type: 'goal_deleted',\n                    title: 'Group Goal Deleted',\n                    message: \"\".concat(adminName, ' deleted the group goal: \"').concat(goal.title, '\"'),\n                    data: {\n                        goal_id: goalId,\n                        goal_title: goal.title,\n                        deleted_by: user.id,\n                        deleted_by_name: adminName\n                    },\n                    read: false\n                }));\n            await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('notifications').insert(notifications);\n        }\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error('Error deleting group goal:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Update group goal (admin only)\n */ async function updateGroupGoal(goalId, updates) {\n    try {\n        const { data: { user } } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) throw new Error('Not authenticated');\n        // Check if user is admin\n        const isAdmin = await isGroupGoalAdmin(goalId, user.id);\n        if (!isAdmin) {\n            throw new Error('Only the goal admin can edit this goal');\n        }\n        const { error } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goals').update(updates).eq('id', goalId);\n        if (error) throw error;\n        // If significant changes, notify members\n        if (updates.title || updates.description || updates.target_date) {\n            const { data: members } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').select('user_id').eq('goal_id', goalId).eq('status', 'accepted').neq('user_id', user.id);\n            if (members && members.length > 0) {\n                const { data: adminProfile } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('profiles').select('first_name, last_name, username').eq('id', user.id).single();\n                const adminName = adminProfile ? \"\".concat(adminProfile.first_name, \" \").concat(adminProfile.last_name).trim() || adminProfile.username : 'Admin';\n                const notifications = members.map((member)=>({\n                        user_id: member.user_id,\n                        type: 'goal_updated',\n                        title: 'Group Goal Updated',\n                        message: \"\".concat(adminName, \" updated the group goal details\"),\n                        data: {\n                            goal_id: goalId,\n                            updated_by: user.id,\n                            updated_by_name: adminName\n                        },\n                        read: false\n                    }));\n                await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('notifications').insert(notifications);\n            }\n        }\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error('Error updating group goal:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Get group goal progress with member stats\n */ async function getGroupGoalProgress(goalId) {\n    try {\n        // Get all activities\n        const { data: activities } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goal_activities').select('id, title, assigned_to, assigned_to_all, completed').eq('goal_id', goalId);\n        if (!activities) return {\n            data: null,\n            success: false\n        };\n        // Get all accepted members\n        const { data: members } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').select('user_id, profile:profiles(first_name, last_name, username)').eq('goal_id', goalId).eq('status', 'accepted');\n        // Get all completions\n        const { data: completions } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('activity_completions').select('activity_id, user_id').eq('goal_id', goalId);\n        const memberProgress = members === null || members === void 0 ? void 0 : members.map((member)=>{\n            const assignedActivities = activities.filter((a)=>a.assigned_to_all || a.assigned_to === member.user_id);\n            const completedActivities = assignedActivities.filter((a)=>completions === null || completions === void 0 ? void 0 : completions.some((c)=>c.activity_id === a.id && c.user_id === member.user_id));\n            const profile = member.profile;\n            return {\n                user_id: member.user_id,\n                name: profile ? \"\".concat(profile.first_name || '', \" \").concat(profile.last_name || '').trim() : 'Unknown',\n                assigned: assignedActivities.length,\n                completed: completedActivities.length,\n                progress: assignedActivities.length > 0 ? Math.round(completedActivities.length / assignedActivities.length * 100) : 0\n            };\n        });\n        // Calculate overall progress\n        const totalAssignedActivities = (memberProgress === null || memberProgress === void 0 ? void 0 : memberProgress.reduce((sum, member)=>sum + member.assigned, 0)) || 0;\n        const totalCompletedActivities = (memberProgress === null || memberProgress === void 0 ? void 0 : memberProgress.reduce((sum, member)=>sum + member.completed, 0)) || 0;\n        const overallProgress = totalAssignedActivities > 0 ? Math.round(totalCompletedActivities / totalAssignedActivities * 100) : 0;\n        return {\n            data: {\n                totalActivities: activities.length,\n                completedActivities: activities.filter((a)=>a.completed).length,\n                overallProgress,\n                memberProgress\n            },\n            success: true\n        };\n    } catch (error) {\n        console.error('Error fetching progress:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Check if all members have responded to group goal invitation\n */ async function checkAllMembersResponded(goalId) {\n    try {\n        const { data: pendingMembers } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').select('id').eq('goal_id', goalId).eq('status', 'pending');\n        return !pendingMembers || pendingMembers.length === 0;\n    } catch (error) {\n        console.error('Error checking member responses:', error);\n        return false;\n    }\n}\n/**\n * Check if user can update group goal progress\n * Only allowed if all members have accepted or declined\n */ async function canUpdateGroupGoalProgress(goalId) {\n    try {\n        const { data: goal } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goals').select('is_group_goal').eq('id', goalId).single();\n        // Not a group goal, can update freely\n        if (!(goal === null || goal === void 0 ? void 0 : goal.is_group_goal)) {\n            return {\n                canUpdate: true\n            };\n        }\n        // Check if all members have responded\n        const allResponded = await checkAllMembersResponded(goalId);\n        if (!allResponded) {\n            return {\n                canUpdate: false,\n                reason: 'Waiting for all members to accept or decline the invitation'\n            };\n        }\n        // Check if at least one member accepted\n        const { data: acceptedMembers } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').select('id').eq('goal_id', goalId).eq('status', 'accepted');\n        if (!acceptedMembers || acceptedMembers.length === 0) {\n            return {\n                canUpdate: false,\n                reason: 'No members have accepted this group goal'\n            };\n        }\n        return {\n            canUpdate: true\n        };\n    } catch (error) {\n        console.error('Error checking update permission:', error);\n        return {\n            canUpdate: false,\n            reason: 'Error checking permissions'\n        };\n    }\n}\n/**\n * Get activity progress for a specific activity\n */ async function getActivityProgress(activityId) {\n    try {\n        // Get activity details\n        const { data: activity } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goal_activities').select('*, goal_id').eq('id', activityId).single();\n        if (!activity) throw new Error('Activity not found');\n        // Get assigned members\n        let assignedMembers = [];\n        if (activity.assigned_to_all) {\n            const { data: allMembers } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').select('user_id, profile:profiles(first_name, last_name, username, profile_picture_url)').eq('goal_id', activity.goal_id).eq('status', 'accepted');\n            assignedMembers = allMembers || [];\n        } else if (activity.assigned_members && activity.assigned_members.length > 0) {\n            const { data: multipleMembers } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('profiles').select('id, first_name, last_name, username, profile_picture_url').in('id', activity.assigned_members);\n            if (multipleMembers) {\n                assignedMembers = multipleMembers.map((member)=>({\n                        user_id: member.id,\n                        profile: member\n                    }));\n            }\n        } else if (activity.assigned_to) {\n            const { data: specificMember } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('profiles').select('id, first_name, last_name, username, profile_picture_url').eq('id', activity.assigned_to).single();\n            if (specificMember) {\n                assignedMembers = [\n                    {\n                        user_id: specificMember.id,\n                        profile: specificMember\n                    }\n                ];\n            }\n        }\n        // Get completions\n        const { data: completions } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('activity_completions').select(\"\\n        *,\\n        user:profiles(first_name, last_name, username, profile_picture_url)\\n      \").eq('activity_id', activityId).order('completed_at', {\n            ascending: false\n        });\n        const completedUserIds = new Set((completions === null || completions === void 0 ? void 0 : completions.map((c)=>c.user_id)) || []);\n        const progressPercentage = assignedMembers.length > 0 ? Math.round(((completions === null || completions === void 0 ? void 0 : completions.length) || 0) / assignedMembers.length * 100) : 0;\n        return {\n            data: {\n                activity,\n                assignedMembers,\n                completions: completions || [],\n                progressPercentage,\n                completedCount: (completions === null || completions === void 0 ? void 0 : completions.length) || 0,\n                totalAssigned: assignedMembers.length\n            },\n            success: true\n        };\n    } catch (error) {\n        console.error('Error fetching activity progress:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aXZlXFxEZXNrdG9wXFxDb21taXRseVxcQ29tbWl0bHlcXGZyb250ZW5kXFxsaWJcXGdyb3VwLWdvYWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR3JvdXAgR29hbHMgU2VydmljZVxuICogSGFuZGxlcyBhbGwgZ3JvdXAgZ29hbCBvcGVyYXRpb25zIGluY2x1ZGluZyBpbnZpdGF0aW9ucywgbWVtYmVyIG1hbmFnZW1lbnQsIGFuZCBhY3Rpdml0eSBhc3NpZ25tZW50c1xuICovXG5cbmltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnLi9zdXBhYmFzZS1jbGllbnQnXG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JvdXBHb2FsTWVtYmVyIHtcbiAgaWQ6IHN0cmluZ1xuICBnb2FsX2lkOiBzdHJpbmdcbiAgdXNlcl9pZDogc3RyaW5nXG4gIHJvbGU6ICdvd25lcicgfCAnbWVtYmVyJ1xuICBzdGF0dXM6ICdwZW5kaW5nJyB8ICdhY2NlcHRlZCcgfCAnZGVjbGluZWQnXG4gIGludml0ZWRfYXQ6IHN0cmluZ1xuICByZXNwb25kZWRfYXQ/OiBzdHJpbmdcbiAgY2FuX2VkaXQ6IGJvb2xlYW5cbiAgcHJvZmlsZT86IHtcbiAgICBmaXJzdF9uYW1lOiBzdHJpbmdcbiAgICBsYXN0X25hbWU6IHN0cmluZ1xuICAgIHVzZXJuYW1lOiBzdHJpbmdcbiAgICBwcm9maWxlX3BpY3R1cmVfdXJsPzogc3RyaW5nXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcm91cEdvYWxJbnZpdGF0aW9uIHtcbiAgaWQ6IHN0cmluZ1xuICBnb2FsX2lkOiBzdHJpbmdcbiAgaW52aXRlcl9pZDogc3RyaW5nXG4gIGludml0ZWVfaWQ6IHN0cmluZ1xuICBzdGF0dXM6ICdwZW5kaW5nJyB8ICdhY2NlcHRlZCcgfCAnZGVjbGluZWQnIHwgJ2NhbmNlbGxlZCdcbiAgbWVzc2FnZT86IHN0cmluZ1xuICBjcmVhdGVkX2F0OiBzdHJpbmdcbiAgcmVzcG9uZGVkX2F0Pzogc3RyaW5nXG4gIGdvYWw/OiB7XG4gICAgdGl0bGU6IHN0cmluZ1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgfVxuICBpbnZpdGVyPzoge1xuICAgIGZpcnN0X25hbWU6IHN0cmluZ1xuICAgIGxhc3RfbmFtZTogc3RyaW5nXG4gICAgdXNlcm5hbWU6IHN0cmluZ1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aXZpdHlBc3NpZ25tZW50IHtcbiAgYWN0aXZpdHlfaWQ6IHN0cmluZ1xuICBhc3NpZ25lZF90bz86IHN0cmluZyAvLyBzcGVjaWZpYyB1c2VyIElEXG4gIGFzc2lnbmVkX3RvX2FsbDogYm9vbGVhblxuICBhY3Rpdml0eV90eXBlOiAnaW5kaXZpZHVhbCcgfCAnY29sbGFib3JhdGl2ZSdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBY3Rpdml0eUNvbXBsZXRpb24ge1xuICBpZDogc3RyaW5nXG4gIGFjdGl2aXR5X2lkOiBzdHJpbmdcbiAgdXNlcl9pZDogc3RyaW5nXG4gIGdvYWxfaWQ6IHN0cmluZ1xuICBjb21wbGV0ZWRfYXQ6IHN0cmluZ1xuICBub3Rlcz86IHN0cmluZ1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGdyb3VwIGdvYWwgd2l0aCBpbml0aWFsIG1lbWJlcnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUdyb3VwR29hbChcbiAgZ29hbERhdGE6IHtcbiAgICB0aXRsZTogc3RyaW5nXG4gICAgZGVzY3JpcHRpb246IHN0cmluZ1xuICAgIGdvYWxfdHlwZTogc3RyaW5nXG4gICAgY2F0ZWdvcnk/OiBzdHJpbmdcbiAgICBwcmlvcml0eT86IHN0cmluZ1xuICAgIHZpc2liaWxpdHk6IHN0cmluZ1xuICB9LFxuICBtZW1iZXJJZHM6IHN0cmluZ1tdXG4pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxuICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCcpXG5cbiAgICAvLyBDcmVhdGUgdGhlIGdvYWxcbiAgICBjb25zdCB7IGRhdGE6IGdvYWwsIGVycm9yOiBnb2FsRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZ29hbHMnKVxuICAgICAgLmluc2VydCh7XG4gICAgICAgIC4uLmdvYWxEYXRhLFxuICAgICAgICB1c2VyX2lkOiB1c2VyLmlkLFxuICAgICAgICBpc19ncm91cF9nb2FsOiB0cnVlLFxuICAgICAgICBncm91cF9nb2FsX3N0YXR1czogJ3BlbmRpbmcnXG4gICAgICB9KVxuICAgICAgLnNlbGVjdCgpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGlmIChnb2FsRXJyb3IpIHRocm93IGdvYWxFcnJvclxuXG4gICAgLy8gQWRkIG93bmVyIGFzIGFjY2VwdGVkIG1lbWJlclxuICAgIGNvbnN0IHsgZXJyb3I6IG1lbWJlckVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdncm91cF9nb2FsX21lbWJlcnMnKS5pbnNlcnQoe1xuICAgICAgZ29hbF9pZDogZ29hbC5pZCxcbiAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICByb2xlOiAnb3duZXInLFxuICAgICAgc3RhdHVzOiAnYWNjZXB0ZWQnLFxuICAgICAgY2FuX2VkaXQ6IHRydWVcbiAgICB9KVxuICAgIFxuICAgIGlmIChtZW1iZXJFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIG93bmVyIGFzIG1lbWJlcjonLCBtZW1iZXJFcnJvcilcbiAgICB9XG5cbiAgICAvLyBTZW5kIGludml0YXRpb25zIHRvIG1lbWJlcnNcbiAgICBjb25zdCBpbnZpdGF0aW9ucyA9IG1lbWJlcklkcy5tYXAobWVtYmVySWQgPT4gKHtcbiAgICAgIGdvYWxfaWQ6IGdvYWwuaWQsXG4gICAgICBpbnZpdGVyX2lkOiB1c2VyLmlkLFxuICAgICAgaW52aXRlZV9pZDogbWVtYmVySWQsXG4gICAgICBzdGF0dXM6ICdwZW5kaW5nJyBhcyBjb25zdCxcbiAgICAgIG1lc3NhZ2U6IGBKb2luIG91ciBncm91cCBnb2FsOiAke2dvYWxEYXRhLnRpdGxlfWBcbiAgICB9KSlcblxuICAgIGNvbnN0IHsgZXJyb3I6IGludml0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2dyb3VwX2dvYWxfaW52aXRhdGlvbnMnKVxuICAgICAgLmluc2VydChpbnZpdGF0aW9ucylcblxuICAgIGlmIChpbnZpdGVFcnJvcikgdGhyb3cgaW52aXRlRXJyb3JcblxuICAgIC8vIENyZWF0ZSBub3RpZmljYXRpb25zIGZvciBpbnZpdGVlc1xuICAgIGNvbnN0IHsgZGF0YTogcHJvZmlsZSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAuc2VsZWN0KCdmaXJzdF9uYW1lLCBsYXN0X25hbWUsIHVzZXJuYW1lJylcbiAgICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICBjb25zdCB1c2VyTmFtZSA9IHByb2ZpbGUgXG4gICAgICA/IGAke3Byb2ZpbGUuZmlyc3RfbmFtZX0gJHtwcm9maWxlLmxhc3RfbmFtZX1gLnRyaW0oKSB8fCBwcm9maWxlLnVzZXJuYW1lXG4gICAgICA6ICdTb21lb25lJ1xuXG4gICAgLy8gSW5zZXJ0IG5vdGlmaWNhdGlvbnMgd2l0aCBwcm9wZXIgc3RydWN0dXJlIGZvciBDb21taXRseVxuICAgIGNvbnN0IG5vdGlmaWNhdGlvbnMgPSBtZW1iZXJJZHMubWFwKG1lbWJlcklkID0+ICh7XG4gICAgICB1c2VyX2lkOiBtZW1iZXJJZCxcbiAgICAgIHR5cGU6ICdhY2NvdW50YWJpbGl0eV9yZXF1ZXN0JywgLy8gVXNlIGV4aXN0aW5nIG5vdGlmaWNhdGlvbiB0eXBlXG4gICAgICB0aXRsZTogJ0dyb3VwIEdvYWwgSW52aXRhdGlvbiDwn46vJyxcbiAgICAgIG1lc3NhZ2U6IGAke3VzZXJOYW1lfSBpbnZpdGVkIHlvdSB0byBqb2luIHRoZSBncm91cCBnb2FsOiBcIiR7Z29hbC50aXRsZX1cImAsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGdvYWxfaWQ6IGdvYWwuaWQsXG4gICAgICAgIGludml0ZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgIGludml0YXRpb25fdHlwZTogJ2dyb3VwX2dvYWwnLFxuICAgICAgICBhY3Rpb25fcmVxdWlyZWQ6IHRydWVcbiAgICAgIH0sXG4gICAgICByZWFkOiBmYWxzZVxuICAgIH0pKVxuXG4gICAgY29uc3QgeyBlcnJvcjogbm90aWZFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbSgnbm90aWZpY2F0aW9ucycpLmluc2VydChub3RpZmljYXRpb25zKVxuICAgIGlmIChub3RpZkVycm9yKSBjb25zb2xlLmVycm9yKCdOb3RpZmljYXRpb24gZXJyb3I6Jywgbm90aWZFcnJvcilcblxuICAgIHJldHVybiB7IGdvYWwsIHN1Y2Nlc3M6IHRydWUgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGdyb3VwIGdvYWw6JywgZXJyb3IpXG4gICAgcmV0dXJuIHsgZXJyb3IsIHN1Y2Nlc3M6IGZhbHNlIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCBwZW5kaW5nIGludml0YXRpb25zIGZvciBjdXJyZW50IHVzZXJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBlbmRpbmdJbnZpdGF0aW9ucygpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxuICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCcpXG5cbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2dyb3VwX2dvYWxfaW52aXRhdGlvbnMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgICosXG4gICAgICAgIGdvYWw6Z29hbHModGl0bGUsIGRlc2NyaXB0aW9uLCBjYXRlZ29yeSksXG4gICAgICAgIGludml0ZXI6cHJvZmlsZXMhZ3JvdXBfZ29hbF9pbnZpdGF0aW9uc19pbnZpdGVyX2lkX2ZrZXkoXG4gICAgICAgICAgZmlyc3RfbmFtZSwgbGFzdF9uYW1lLCB1c2VybmFtZSwgcHJvZmlsZV9waWN0dXJlX3VybFxuICAgICAgICApXG4gICAgICBgKVxuICAgICAgLmVxKCdpbnZpdGVlX2lkJywgdXNlci5pZClcbiAgICAgIC5lcSgnc3RhdHVzJywgJ3BlbmRpbmcnKVxuICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgcmV0dXJuIHsgZGF0YSwgc3VjY2VzczogdHJ1ZSB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgaW52aXRhdGlvbnM6JywgZXJyb3IpXG4gICAgcmV0dXJuIHsgZXJyb3IsIHN1Y2Nlc3M6IGZhbHNlIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdCBncm91cCBnb2FsIGludml0YXRpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFjY2VwdEdyb3VwR29hbEludml0YXRpb24oaW52aXRhdGlvbklkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxuICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCcpXG5cbiAgICAvLyBHZXQgaW52aXRhdGlvbiBkZXRhaWxzXG4gICAgY29uc3QgeyBkYXRhOiBpbnZpdGF0aW9uIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2dyb3VwX2dvYWxfaW52aXRhdGlvbnMnKVxuICAgICAgLnNlbGVjdCgnZ29hbF9pZCwgaW52aXRlZV9pZCcpXG4gICAgICAuZXEoJ2lkJywgaW52aXRhdGlvbklkKVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICBpZiAoIWludml0YXRpb24pIHRocm93IG5ldyBFcnJvcignSW52aXRhdGlvbiBub3QgZm91bmQnKVxuXG4gICAgLy8gVXBkYXRlIGludml0YXRpb24gc3RhdHVzXG4gICAgY29uc3QgeyBlcnJvcjogaW52aXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZ3JvdXBfZ29hbF9pbnZpdGF0aW9ucycpXG4gICAgICAudXBkYXRlKHtcbiAgICAgICAgc3RhdHVzOiAnYWNjZXB0ZWQnLFxuICAgICAgICByZXNwb25kZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSlcbiAgICAgIC5lcSgnaWQnLCBpbnZpdGF0aW9uSWQpXG4gICAgICAuZXEoJ2ludml0ZWVfaWQnLCB1c2VyLmlkKVxuXG4gICAgaWYgKGludml0ZUVycm9yKSB0aHJvdyBpbnZpdGVFcnJvclxuXG4gICAgLy8gQWRkIHVzZXIgYXMgYWNjZXB0ZWQgbWVtYmVyXG4gICAgY29uc3QgeyBlcnJvcjogbWVtYmVyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZ3JvdXBfZ29hbF9tZW1iZXJzJylcbiAgICAgIC51cHNlcnQoe1xuICAgICAgICBnb2FsX2lkOiBpbnZpdGF0aW9uLmdvYWxfaWQsXG4gICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgIHJvbGU6ICdtZW1iZXInLFxuICAgICAgICBzdGF0dXM6ICdhY2NlcHRlZCcsXG4gICAgICAgIGNhbl9lZGl0OiBmYWxzZVxuICAgICAgfSlcblxuICAgIGlmIChtZW1iZXJFcnJvcikgdGhyb3cgbWVtYmVyRXJyb3JcblxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFjY2VwdGluZyBpbnZpdGF0aW9uOicsIGVycm9yKVxuICAgIHJldHVybiB7IGVycm9yLCBzdWNjZXNzOiBmYWxzZSB9XG4gIH1cbn1cblxuLyoqXG4gKiBEZWNsaW5lIGdyb3VwIGdvYWwgaW52aXRhdGlvblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVjbGluZUdyb3VwR29hbEludml0YXRpb24oaW52aXRhdGlvbklkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxuICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCcpXG5cbiAgICAvLyBHZXQgaW52aXRhdGlvbiBkZXRhaWxzXG4gICAgY29uc3QgeyBkYXRhOiBpbnZpdGF0aW9uIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2dyb3VwX2dvYWxfaW52aXRhdGlvbnMnKVxuICAgICAgLnNlbGVjdCgnZ29hbF9pZCwgaW52aXRlZV9pZCcpXG4gICAgICAuZXEoJ2lkJywgaW52aXRhdGlvbklkKVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICBpZiAoIWludml0YXRpb24pIHRocm93IG5ldyBFcnJvcignSW52aXRhdGlvbiBub3QgZm91bmQnKVxuXG4gICAgLy8gVXBkYXRlIGludml0YXRpb24gc3RhdHVzXG4gICAgY29uc3QgeyBlcnJvcjogaW52aXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZ3JvdXBfZ29hbF9pbnZpdGF0aW9ucycpXG4gICAgICAudXBkYXRlKHtcbiAgICAgICAgc3RhdHVzOiAnZGVjbGluZWQnLFxuICAgICAgICByZXNwb25kZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSlcbiAgICAgIC5lcSgnaWQnLCBpbnZpdGF0aW9uSWQpXG4gICAgICAuZXEoJ2ludml0ZWVfaWQnLCB1c2VyLmlkKVxuXG4gICAgaWYgKGludml0ZUVycm9yKSB0aHJvdyBpbnZpdGVFcnJvclxuXG4gICAgLy8gQWRkIHVzZXIgYXMgZGVjbGluZWQgbWVtYmVyICh0cmlnZ2VycyBhY3Rpdml0eSByZWFzc2lnbm1lbnQpXG4gICAgY29uc3QgeyBlcnJvcjogbWVtYmVyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZ3JvdXBfZ29hbF9tZW1iZXJzJylcbiAgICAgIC51cHNlcnQoe1xuICAgICAgICBnb2FsX2lkOiBpbnZpdGF0aW9uLmdvYWxfaWQsXG4gICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgIHJvbGU6ICdtZW1iZXInLFxuICAgICAgICBzdGF0dXM6ICdkZWNsaW5lZCcsXG4gICAgICAgIGNhbl9lZGl0OiBmYWxzZVxuICAgICAgfSlcblxuICAgIGlmIChtZW1iZXJFcnJvcikgdGhyb3cgbWVtYmVyRXJyb3JcblxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlY2xpbmluZyBpbnZpdGF0aW9uOicsIGVycm9yKVxuICAgIHJldHVybiB7IGVycm9yLCBzdWNjZXNzOiBmYWxzZSB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgZ3JvdXAgZ29hbCBtZW1iZXJzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRHcm91cEdvYWxNZW1iZXJzKGdvYWxJZDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdncm91cF9nb2FsX21lbWJlcnMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgICosXG4gICAgICAgIHByb2ZpbGU6cHJvZmlsZXMoZmlyc3RfbmFtZSwgbGFzdF9uYW1lLCB1c2VybmFtZSwgcHJvZmlsZV9waWN0dXJlX3VybClcbiAgICAgIGApXG4gICAgICAuZXEoJ2dvYWxfaWQnLCBnb2FsSWQpXG4gICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxuXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgIHJldHVybiB7IGRhdGEsIHN1Y2Nlc3M6IHRydWUgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIG1lbWJlcnM6JywgZXJyb3IpXG4gICAgcmV0dXJuIHsgZXJyb3IsIHN1Y2Nlc3M6IGZhbHNlIH1cbiAgfVxufVxuXG4vKipcbiAqIEFzc2lnbiBhY3Rpdml0eSB0byB1c2VyKHMpIChkZXByZWNhdGVkIC0gdXNlIHVwZGF0ZUFjdGl2aXR5QXNzaWdubWVudClcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzc2lnbkFjdGl2aXR5KFxuICBhY3Rpdml0eUlkOiBzdHJpbmcsXG4gIGFzc2lnbm1lbnQ6IHsgYXNzaWduZWRUbz86IHN0cmluZzsgYXNzaWduZWRUb0FsbDogYm9vbGVhbiB9XG4pIHtcbiAgcmV0dXJuIHVwZGF0ZUFjdGl2aXR5QXNzaWdubWVudChhY3Rpdml0eUlkLCBhc3NpZ25tZW50KVxufVxuXG4vKipcbiAqIENvbXBsZXRlIGFjdGl2aXR5IGZvciBjdXJyZW50IHVzZXJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbXBsZXRlQWN0aXZpdHkoXG4gIGFjdGl2aXR5SWQ6IHN0cmluZyxcbiAgZ29hbElkOiBzdHJpbmcsXG4gIG5vdGVzPzogc3RyaW5nXG4pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxuICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCcpXG5cbiAgICAvLyBDaGVjayBpZiBhY3Rpdml0eSBpcyBhc3NpZ25lZCB0byB0aGlzIHVzZXJcbiAgICBjb25zdCB7IGRhdGE6IGFjdGl2aXR5IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2dvYWxfYWN0aXZpdGllcycpXG4gICAgICAuc2VsZWN0KCdhc3NpZ25lZF90bywgYXNzaWduZWRfdG9fYWxsLCBhc3NpZ25lZF9tZW1iZXJzLCB0aXRsZScpXG4gICAgICAuZXEoJ2lkJywgYWN0aXZpdHlJZClcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgaWYgKCFhY3Rpdml0eSkgdGhyb3cgbmV3IEVycm9yKCdBY3Rpdml0eSBub3QgZm91bmQnKVxuXG4gICAgLy8gVmVyaWZ5IHVzZXIgY2FuIGNvbXBsZXRlIHRoaXMgYWN0aXZpdHlcbiAgICBjb25zdCBjYW5Db21wbGV0ZSA9IGFjdGl2aXR5LmFzc2lnbmVkX3RvX2FsbCB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZpdHkuYXNzaWduZWRfdG8gPT09IHVzZXIuaWQgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgIChhY3Rpdml0eS5hc3NpZ25lZF9tZW1iZXJzICYmIGFjdGl2aXR5LmFzc2lnbmVkX21lbWJlcnMuaW5jbHVkZXModXNlci5pZCkpXG4gICAgXG4gICAgaWYgKCFjYW5Db21wbGV0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIG5vdCBhc3NpZ25lZCB0byB0aGlzIGFjdGl2aXR5JylcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhbHJlYWR5IGNvbXBsZXRlZCBieSB0aGlzIHVzZXJcbiAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nQ29tcGxldGlvbiB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdhY3Rpdml0eV9jb21wbGV0aW9ucycpXG4gICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAuZXEoJ2FjdGl2aXR5X2lkJywgYWN0aXZpdHlJZClcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGlmIChleGlzdGluZ0NvbXBsZXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aXZpdHkgYWxyZWFkeSBjb21wbGV0ZWQgYnkgeW91JylcbiAgICB9XG5cbiAgICAvLyBJbnNlcnQgY29tcGxldGlvbiByZWNvcmRcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2FjdGl2aXR5X2NvbXBsZXRpb25zJylcbiAgICAgIC5pbnNlcnQoe1xuICAgICAgICBhY3Rpdml0eV9pZDogYWN0aXZpdHlJZCxcbiAgICAgICAgdXNlcl9pZDogdXNlci5pZCxcbiAgICAgICAgZ29hbF9pZDogZ29hbElkLFxuICAgICAgICBub3Rlc1xuICAgICAgfSlcblxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgIC8vIE5vdGlmeSBvdGhlciBncm91cCBtZW1iZXJzXG4gICAgY29uc3QgeyBkYXRhOiBtZW1iZXJzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2dyb3VwX2dvYWxfbWVtYmVycycpXG4gICAgICAuc2VsZWN0KCd1c2VyX2lkJylcbiAgICAgIC5lcSgnZ29hbF9pZCcsIGdvYWxJZClcbiAgICAgIC5lcSgnc3RhdHVzJywgJ2FjY2VwdGVkJylcbiAgICAgIC5uZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuXG4gICAgaWYgKG1lbWJlcnMgJiYgbWVtYmVycy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB7IGRhdGE6IHVzZXJQcm9maWxlIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAuc2VsZWN0KCdmaXJzdF9uYW1lLCBsYXN0X25hbWUsIHVzZXJuYW1lJylcbiAgICAgICAgLmVxKCdpZCcsIHVzZXIuaWQpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBjb25zdCB1c2VyTmFtZSA9IHVzZXJQcm9maWxlIFxuICAgICAgICA/IGAke3VzZXJQcm9maWxlLmZpcnN0X25hbWV9ICR7dXNlclByb2ZpbGUubGFzdF9uYW1lfWAudHJpbSgpIHx8IHVzZXJQcm9maWxlLnVzZXJuYW1lXG4gICAgICAgIDogJ1NvbWVvbmUnXG5cbiAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbnMgPSBtZW1iZXJzLm1hcChtZW1iZXIgPT4gKHtcbiAgICAgICAgdXNlcl9pZDogbWVtYmVyLnVzZXJfaWQsXG4gICAgICAgIHR5cGU6ICdhY3Rpdml0eV9jb21wbGV0ZWQnLFxuICAgICAgICB0aXRsZTogJ0FjdGl2aXR5IENvbXBsZXRlZCEg8J+OiScsXG4gICAgICAgIG1lc3NhZ2U6IGAke3VzZXJOYW1lfSBjb21wbGV0ZWQ6IFwiJHthY3Rpdml0eS50aXRsZX1cImAsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBhY3Rpdml0eV9pZDogYWN0aXZpdHlJZCxcbiAgICAgICAgICBnb2FsX2lkOiBnb2FsSWQsXG4gICAgICAgICAgY29tcGxldGVkX2J5OiB1c2VyLmlkLFxuICAgICAgICAgIGNvbXBsZXRlZF9ieV9uYW1lOiB1c2VyTmFtZVxuICAgICAgICB9LFxuICAgICAgICByZWFkOiBmYWxzZVxuICAgICAgfSkpXG5cbiAgICAgIGF3YWl0IHN1cGFiYXNlLmZyb20oJ25vdGlmaWNhdGlvbnMnKS5pbnNlcnQobm90aWZpY2F0aW9ucylcbiAgICB9XG5cbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjb21wbGV0aW5nIGFjdGl2aXR5OicsIGVycm9yKVxuICAgIHJldHVybiB7IGVycm9yLCBzdWNjZXNzOiBmYWxzZSB9XG4gIH1cbn1cblxuLyoqXG4gKiBVbmNvbXBsZXRlIGFjdGl2aXR5IGZvciBjdXJyZW50IHVzZXIgKHJlbW92ZSBjb21wbGV0aW9uKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdW5jb21wbGV0ZUFjdGl2aXR5KGFjdGl2aXR5SWQ6IHN0cmluZywgZ29hbElkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxuICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCcpXG5cbiAgICAvLyBDaGVjayBpZiB1c2VyIGNhbiBlZGl0IHRoaXMgYWN0aXZpdHlcbiAgICBjb25zdCBjYW5FZGl0ID0gYXdhaXQgY2FuVXNlckVkaXRBY3Rpdml0eShhY3Rpdml0eUlkLCB1c2VyLmlkKVxuICAgIGlmICghY2FuRWRpdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IHVuY29tcGxldGUgdGhpcyBhY3Rpdml0eScpXG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGNvbXBsZXRpb24gcmVjb3JkXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdhY3Rpdml0eV9jb21wbGV0aW9ucycpXG4gICAgICAuZGVsZXRlKClcbiAgICAgIC5lcSgnYWN0aXZpdHlfaWQnLCBhY3Rpdml0eUlkKVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcblxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1bmNvbXBsZXRpbmcgYWN0aXZpdHk6JywgZXJyb3IpXG4gICAgcmV0dXJuIHsgZXJyb3IsIHN1Y2Nlc3M6IGZhbHNlIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCBhY3Rpdml0eSBjb21wbGV0aW9uIHN0YXR1cyBmb3IgZ3JvdXAgZ29hbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWN0aXZpdHlDb21wbGV0aW9ucyhhY3Rpdml0eUlkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2FjdGl2aXR5X2NvbXBsZXRpb25zJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICAqLFxuICAgICAgICB1c2VyOnByb2ZpbGVzKGZpcnN0X25hbWUsIGxhc3RfbmFtZSwgdXNlcm5hbWUsIHByb2ZpbGVfcGljdHVyZV91cmwpXG4gICAgICBgKVxuICAgICAgLmVxKCdhY3Rpdml0eV9pZCcsIGFjdGl2aXR5SWQpXG4gICAgICAub3JkZXIoJ2NvbXBsZXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgIHJldHVybiB7IGRhdGEsIHN1Y2Nlc3M6IHRydWUgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGNvbXBsZXRpb25zOicsIGVycm9yKVxuICAgIHJldHVybiB7IGVycm9yLCBzdWNjZXNzOiBmYWxzZSB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiB1c2VyIGNhbiB1cGRhdGUgYWN0aXZpdHkgKGRlcHJlY2F0ZWQgLSB1c2UgY2FuVXNlckVkaXRBY3Rpdml0eSlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhblVzZXJVcGRhdGVBY3Rpdml0eShhY3Rpdml0eUlkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKSB7XG4gIHJldHVybiBjYW5Vc2VyRWRpdEFjdGl2aXR5KGFjdGl2aXR5SWQsIHVzZXJJZClcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB1c2VyIGlzIGFkbWluIChvd25lcikgb2YgYSBncm91cCBnb2FsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpc0dyb3VwR29hbEFkbWluKGdvYWxJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIC8vIENoZWNrIGlmIHVzZXIgaXMgdGhlIGdvYWwgb3duZXJcbiAgICBjb25zdCB7IGRhdGE6IGdvYWwgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZ29hbHMnKVxuICAgICAgLnNlbGVjdCgndXNlcl9pZCwgaXNfZ3JvdXBfZ29hbCcpXG4gICAgICAuZXEoJ2lkJywgZ29hbElkKVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICBpZiAoIWdvYWwpIHJldHVybiBmYWxzZVxuICAgIFxuICAgIC8vIEZvciBncm91cCBnb2FscywgY2hlY2sgaWYgdXNlciBpcyB0aGUgb3duZXJcbiAgICBpZiAoZ29hbC5pc19ncm91cF9nb2FsKSB7XG4gICAgICByZXR1cm4gZ29hbC51c2VyX2lkID09PSB1c2VySWRcbiAgICB9XG4gICAgXG4gICAgLy8gRm9yIHJlZ3VsYXIgZ29hbHMsIG9ubHkgb3duZXIgY2FuIG1hbmFnZVxuICAgIHJldHVybiBnb2FsLnVzZXJfaWQgPT09IHVzZXJJZFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIGFkbWluIHBlcm1pc3Npb25zOicsIGVycm9yKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdXNlciBjYW4gZWRpdCBhIHNwZWNpZmljIGFjdGl2aXR5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYW5Vc2VyRWRpdEFjdGl2aXR5KGFjdGl2aXR5SWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGE6IGFjdGl2aXR5IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2dvYWxfYWN0aXZpdGllcycpXG4gICAgICAuc2VsZWN0KCdhc3NpZ25lZF90bywgYXNzaWduZWRfdG9fYWxsLCBhc3NpZ25lZF9tZW1iZXJzLCBnb2FsX2lkJylcbiAgICAgIC5lcSgnaWQnLCBhY3Rpdml0eUlkKVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICBpZiAoIWFjdGl2aXR5KSByZXR1cm4gZmFsc2VcblxuICAgIC8vIENoZWNrIGlmIHVzZXIgaXMgZ29hbCBhZG1pbiBmaXJzdFxuICAgIGNvbnN0IGlzQWRtaW4gPSBhd2FpdCBpc0dyb3VwR29hbEFkbWluKGFjdGl2aXR5LmdvYWxfaWQsIHVzZXJJZClcbiAgICBpZiAoaXNBZG1pbikgcmV0dXJuIHRydWVcblxuICAgIC8vIENoZWNrIGlmIGFjdGl2aXR5IGlzIGFzc2lnbmVkIHRvIHRoaXMgdXNlclxuICAgIGlmIChhY3Rpdml0eS5hc3NpZ25lZF90b19hbGwpIHJldHVybiB0cnVlXG4gICAgaWYgKGFjdGl2aXR5LmFzc2lnbmVkX3RvID09PSB1c2VySWQpIHJldHVybiB0cnVlXG4gICAgaWYgKGFjdGl2aXR5LmFzc2lnbmVkX21lbWJlcnMgJiYgYWN0aXZpdHkuYXNzaWduZWRfbWVtYmVycy5pbmNsdWRlcyh1c2VySWQpKSByZXR1cm4gdHJ1ZVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgYWN0aXZpdHkgZWRpdCBwZXJtaXNzaW9uczonLCBlcnJvcilcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIEdldCBkZXRhaWxlZCBncm91cCBnb2FsIHdpdGggbWVtYmVycyBhbmQgYWN0aXZpdGllc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0R3JvdXBHb2FsRGV0YWlscyhnb2FsSWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIC8vIEdldCBnb2FsIGRldGFpbHNcbiAgICBjb25zdCB7IGRhdGE6IGdvYWwsIGVycm9yOiBnb2FsRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZ29hbHMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2lkJywgZ29hbElkKVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICBpZiAoZ29hbEVycm9yKSB0aHJvdyBnb2FsRXJyb3JcblxuICAgIC8vIEdldCBtZW1iZXJzXG4gICAgY29uc3QgeyBkYXRhOiBtZW1iZXJzLCBlcnJvcjogbWVtYmVyc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2dyb3VwX2dvYWxfbWVtYmVycycpXG4gICAgICAuc2VsZWN0KGBcbiAgICAgICAgKixcbiAgICAgICAgcHJvZmlsZTpwcm9maWxlcyhmaXJzdF9uYW1lLCBsYXN0X25hbWUsIHVzZXJuYW1lLCBwcm9maWxlX3BpY3R1cmVfdXJsKVxuICAgICAgYClcbiAgICAgIC5lcSgnZ29hbF9pZCcsIGdvYWxJZClcbiAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXG5cbiAgICBpZiAobWVtYmVyc0Vycm9yKSB0aHJvdyBtZW1iZXJzRXJyb3JcblxuICAgIC8vIEdldCBhY3Rpdml0aWVzIHdpdGggYXNzaWdubWVudHNcbiAgICBjb25zdCB7IGRhdGE6IGFjdGl2aXRpZXMsIGVycm9yOiBhY3Rpdml0aWVzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZ29hbF9hY3Rpdml0aWVzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdnb2FsX2lkJywgZ29hbElkKVxuICAgICAgLm9yZGVyKCdvcmRlcl9pbmRleCcsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXG5cbiAgICBpZiAoYWN0aXZpdGllc0Vycm9yKSB0aHJvdyBhY3Rpdml0aWVzRXJyb3JcblxuICAgIC8vIEdldCBhY3Rpdml0eSBjb21wbGV0aW9uc1xuICAgIGNvbnN0IHsgZGF0YTogY29tcGxldGlvbnMsIGVycm9yOiBjb21wbGV0aW9uc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2FjdGl2aXR5X2NvbXBsZXRpb25zJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICAqLFxuICAgICAgICB1c2VyOnByb2ZpbGVzKGZpcnN0X25hbWUsIGxhc3RfbmFtZSwgdXNlcm5hbWUsIHByb2ZpbGVfcGljdHVyZV91cmwpXG4gICAgICBgKVxuICAgICAgLmVxKCdnb2FsX2lkJywgZ29hbElkKVxuICAgICAgLm9yZGVyKCdjb21wbGV0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgIGlmIChjb21wbGV0aW9uc0Vycm9yKSB0aHJvdyBjb21wbGV0aW9uc0Vycm9yXG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YToge1xuICAgICAgICBnb2FsLFxuICAgICAgICBtZW1iZXJzOiBtZW1iZXJzIHx8IFtdLFxuICAgICAgICBhY3Rpdml0aWVzOiBhY3Rpdml0aWVzIHx8IFtdLFxuICAgICAgICBjb21wbGV0aW9uczogY29tcGxldGlvbnMgfHwgW11cbiAgICAgIH0sXG4gICAgICBzdWNjZXNzOiB0cnVlXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGdyb3VwIGdvYWwgZGV0YWlsczonLCBlcnJvcilcbiAgICByZXR1cm4geyBlcnJvciwgc3VjY2VzczogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogVXBkYXRlIGFjdGl2aXR5IGFzc2lnbm1lbnQgKGFkbWluIG9ubHkpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVBY3Rpdml0eUFzc2lnbm1lbnQoXG4gIGFjdGl2aXR5SWQ6IHN0cmluZyxcbiAgYXNzaWdubWVudDogeyBhc3NpZ25lZFRvPzogc3RyaW5nOyBhc3NpZ25lZFRvQWxsOiBib29sZWFuOyBhc3NpZ25lZE1lbWJlcnM/OiBzdHJpbmdbXSB9XG4pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxuICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCcpXG5cbiAgICAvLyBHZXQgYWN0aXZpdHkgdG8gY2hlY2sgcGVybWlzc2lvbnNcbiAgICBjb25zdCB7IGRhdGE6IGFjdGl2aXR5IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2dvYWxfYWN0aXZpdGllcycpXG4gICAgICAuc2VsZWN0KCdnb2FsX2lkJylcbiAgICAgIC5lcSgnaWQnLCBhY3Rpdml0eUlkKVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICBpZiAoIWFjdGl2aXR5KSB0aHJvdyBuZXcgRXJyb3IoJ0FjdGl2aXR5IG5vdCBmb3VuZCcpXG5cbiAgICAvLyBDaGVjayBpZiB1c2VyIGlzIGFkbWluXG4gICAgY29uc3QgaXNBZG1pbiA9IGF3YWl0IGlzR3JvdXBHb2FsQWRtaW4oYWN0aXZpdHkuZ29hbF9pZCwgdXNlci5pZClcbiAgICBpZiAoIWlzQWRtaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBhZG1pbnMgY2FuIHVwZGF0ZSBhY3Rpdml0eSBhc3NpZ25tZW50cycpXG4gICAgfVxuXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdnb2FsX2FjdGl2aXRpZXMnKVxuICAgICAgLnVwZGF0ZSh7XG4gICAgICAgIGFzc2lnbmVkX3RvOiBhc3NpZ25tZW50LmFzc2lnbmVkVG8gfHwgbnVsbCxcbiAgICAgICAgYXNzaWduZWRfdG9fYWxsOiBhc3NpZ25tZW50LmFzc2lnbmVkVG9BbGwsXG4gICAgICAgIGFzc2lnbmVkX21lbWJlcnM6IGFzc2lnbm1lbnQuYXNzaWduZWRNZW1iZXJzIHx8IG51bGwsXG4gICAgICAgIGFjdGl2aXR5X3R5cGU6IGFzc2lnbm1lbnQuYXNzaWduZWRUb0FsbCA/ICdjb2xsYWJvcmF0aXZlJyA6IChhc3NpZ25tZW50LmFzc2lnbmVkTWVtYmVycz8ubGVuZ3RoID8gJ211bHRpX21lbWJlcicgOiAnaW5kaXZpZHVhbCcpXG4gICAgICB9KVxuICAgICAgLmVxKCdpZCcsIGFjdGl2aXR5SWQpXG5cbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBhY3Rpdml0eSBhc3NpZ25tZW50OicsIGVycm9yKVxuICAgIHJldHVybiB7IGVycm9yLCBzdWNjZXNzOiBmYWxzZSB9XG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGUgZ3JvdXAgZ29hbCAoYWRtaW4gb25seSlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUdyb3VwR29hbChnb2FsSWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpXG4gICAgaWYgKCF1c2VyKSB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdXRoZW50aWNhdGVkJylcblxuICAgIC8vIENoZWNrIGlmIHVzZXIgaXMgYWRtaW5cbiAgICBjb25zdCBpc0FkbWluID0gYXdhaXQgaXNHcm91cEdvYWxBZG1pbihnb2FsSWQsIHVzZXIuaWQpXG4gICAgaWYgKCFpc0FkbWluKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgdGhlIGdvYWwgYWRtaW4gY2FuIGRlbGV0ZSB0aGlzIGdvYWwnKVxuICAgIH1cblxuICAgIC8vIEdldCBnb2FsIGRldGFpbHMgZm9yIG5vdGlmaWNhdGlvbnNcbiAgICBjb25zdCB7IGRhdGE6IGdvYWwgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZ29hbHMnKVxuICAgICAgLnNlbGVjdCgndGl0bGUnKVxuICAgICAgLmVxKCdpZCcsIGdvYWxJZClcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgLy8gR2V0IGFsbCBtZW1iZXJzIHRvIG5vdGlmeSB0aGVtXG4gICAgY29uc3QgeyBkYXRhOiBtZW1iZXJzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2dyb3VwX2dvYWxfbWVtYmVycycpXG4gICAgICAuc2VsZWN0KCd1c2VyX2lkLCBwcm9maWxlOnByb2ZpbGVzKGZpcnN0X25hbWUsIGxhc3RfbmFtZSknKVxuICAgICAgLmVxKCdnb2FsX2lkJywgZ29hbElkKVxuICAgICAgLmVxKCdzdGF0dXMnLCAnYWNjZXB0ZWQnKVxuICAgICAgLm5lcSgndXNlcl9pZCcsIHVzZXIuaWQpIC8vIEV4Y2x1ZGUgdGhlIGFkbWluXG5cbiAgICAvLyBEZWxldGUgdGhlIGdvYWwgKGNhc2NhZGUgd2lsbCBoYW5kbGUgcmVsYXRlZCByZWNvcmRzKVxuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZ29hbHMnKVxuICAgICAgLmRlbGV0ZSgpXG4gICAgICAuZXEoJ2lkJywgZ29hbElkKVxuXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgLy8gTm90aWZ5IGFsbCBtZW1iZXJzIGFib3V0IGdvYWwgZGVsZXRpb25cbiAgICBpZiAobWVtYmVycyAmJiBtZW1iZXJzLmxlbmd0aCA+IDAgJiYgZ29hbCkge1xuICAgICAgY29uc3QgeyBkYXRhOiBhZG1pblByb2ZpbGUgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgIC5zZWxlY3QoJ2ZpcnN0X25hbWUsIGxhc3RfbmFtZSwgdXNlcm5hbWUnKVxuICAgICAgICAuZXEoJ2lkJywgdXNlci5pZClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGNvbnN0IGFkbWluTmFtZSA9IGFkbWluUHJvZmlsZSBcbiAgICAgICAgPyBgJHthZG1pblByb2ZpbGUuZmlyc3RfbmFtZX0gJHthZG1pblByb2ZpbGUubGFzdF9uYW1lfWAudHJpbSgpIHx8IGFkbWluUHJvZmlsZS51c2VybmFtZVxuICAgICAgICA6ICdBZG1pbidcblxuICAgICAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IG1lbWJlcnMubWFwKG1lbWJlciA9PiAoe1xuICAgICAgICB1c2VyX2lkOiBtZW1iZXIudXNlcl9pZCxcbiAgICAgICAgdHlwZTogJ2dvYWxfZGVsZXRlZCcsXG4gICAgICAgIHRpdGxlOiAnR3JvdXAgR29hbCBEZWxldGVkJyxcbiAgICAgICAgbWVzc2FnZTogYCR7YWRtaW5OYW1lfSBkZWxldGVkIHRoZSBncm91cCBnb2FsOiBcIiR7Z29hbC50aXRsZX1cImAsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBnb2FsX2lkOiBnb2FsSWQsXG4gICAgICAgICAgZ29hbF90aXRsZTogZ29hbC50aXRsZSxcbiAgICAgICAgICBkZWxldGVkX2J5OiB1c2VyLmlkLFxuICAgICAgICAgIGRlbGV0ZWRfYnlfbmFtZTogYWRtaW5OYW1lXG4gICAgICAgIH0sXG4gICAgICAgIHJlYWQ6IGZhbHNlXG4gICAgICB9KSlcblxuICAgICAgYXdhaXQgc3VwYWJhc2UuZnJvbSgnbm90aWZpY2F0aW9ucycpLmluc2VydChub3RpZmljYXRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIGdyb3VwIGdvYWw6JywgZXJyb3IpXG4gICAgcmV0dXJuIHsgZXJyb3IsIHN1Y2Nlc3M6IGZhbHNlIH1cbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSBncm91cCBnb2FsIChhZG1pbiBvbmx5KVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlR3JvdXBHb2FsKGdvYWxJZDogc3RyaW5nLCB1cGRhdGVzOiBhbnkpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxuICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCcpXG5cbiAgICAvLyBDaGVjayBpZiB1c2VyIGlzIGFkbWluXG4gICAgY29uc3QgaXNBZG1pbiA9IGF3YWl0IGlzR3JvdXBHb2FsQWRtaW4oZ29hbElkLCB1c2VyLmlkKVxuICAgIGlmICghaXNBZG1pbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IHRoZSBnb2FsIGFkbWluIGNhbiBlZGl0IHRoaXMgZ29hbCcpXG4gICAgfVxuXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdnb2FscycpXG4gICAgICAudXBkYXRlKHVwZGF0ZXMpXG4gICAgICAuZXEoJ2lkJywgZ29hbElkKVxuXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgLy8gSWYgc2lnbmlmaWNhbnQgY2hhbmdlcywgbm90aWZ5IG1lbWJlcnNcbiAgICBpZiAodXBkYXRlcy50aXRsZSB8fCB1cGRhdGVzLmRlc2NyaXB0aW9uIHx8IHVwZGF0ZXMudGFyZ2V0X2RhdGUpIHtcbiAgICAgIGNvbnN0IHsgZGF0YTogbWVtYmVycyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2dyb3VwX2dvYWxfbWVtYmVycycpXG4gICAgICAgIC5zZWxlY3QoJ3VzZXJfaWQnKVxuICAgICAgICAuZXEoJ2dvYWxfaWQnLCBnb2FsSWQpXG4gICAgICAgIC5lcSgnc3RhdHVzJywgJ2FjY2VwdGVkJylcbiAgICAgICAgLm5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG5cbiAgICAgIGlmIChtZW1iZXJzICYmIG1lbWJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB7IGRhdGE6IGFkbWluUHJvZmlsZSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAgIC5zZWxlY3QoJ2ZpcnN0X25hbWUsIGxhc3RfbmFtZSwgdXNlcm5hbWUnKVxuICAgICAgICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxuICAgICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICAgIGNvbnN0IGFkbWluTmFtZSA9IGFkbWluUHJvZmlsZSBcbiAgICAgICAgICA/IGAke2FkbWluUHJvZmlsZS5maXJzdF9uYW1lfSAke2FkbWluUHJvZmlsZS5sYXN0X25hbWV9YC50cmltKCkgfHwgYWRtaW5Qcm9maWxlLnVzZXJuYW1lXG4gICAgICAgICAgOiAnQWRtaW4nXG5cbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IG1lbWJlcnMubWFwKG1lbWJlciA9PiAoe1xuICAgICAgICAgIHVzZXJfaWQ6IG1lbWJlci51c2VyX2lkLFxuICAgICAgICAgIHR5cGU6ICdnb2FsX3VwZGF0ZWQnLFxuICAgICAgICAgIHRpdGxlOiAnR3JvdXAgR29hbCBVcGRhdGVkJyxcbiAgICAgICAgICBtZXNzYWdlOiBgJHthZG1pbk5hbWV9IHVwZGF0ZWQgdGhlIGdyb3VwIGdvYWwgZGV0YWlsc2AsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZ29hbF9pZDogZ29hbElkLFxuICAgICAgICAgICAgdXBkYXRlZF9ieTogdXNlci5pZCxcbiAgICAgICAgICAgIHVwZGF0ZWRfYnlfbmFtZTogYWRtaW5OYW1lXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWFkOiBmYWxzZVxuICAgICAgICB9KSlcblxuICAgICAgICBhd2FpdCBzdXBhYmFzZS5mcm9tKCdub3RpZmljYXRpb25zJykuaW5zZXJ0KG5vdGlmaWNhdGlvbnMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgZ3JvdXAgZ29hbDonLCBlcnJvcilcbiAgICByZXR1cm4geyBlcnJvciwgc3VjY2VzczogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IGdyb3VwIGdvYWwgcHJvZ3Jlc3Mgd2l0aCBtZW1iZXIgc3RhdHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEdyb3VwR29hbFByb2dyZXNzKGdvYWxJZDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgLy8gR2V0IGFsbCBhY3Rpdml0aWVzXG4gICAgY29uc3QgeyBkYXRhOiBhY3Rpdml0aWVzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2dvYWxfYWN0aXZpdGllcycpXG4gICAgICAuc2VsZWN0KCdpZCwgdGl0bGUsIGFzc2lnbmVkX3RvLCBhc3NpZ25lZF90b19hbGwsIGNvbXBsZXRlZCcpXG4gICAgICAuZXEoJ2dvYWxfaWQnLCBnb2FsSWQpXG5cbiAgICBpZiAoIWFjdGl2aXRpZXMpIHJldHVybiB7IGRhdGE6IG51bGwsIHN1Y2Nlc3M6IGZhbHNlIH1cblxuICAgIC8vIEdldCBhbGwgYWNjZXB0ZWQgbWVtYmVyc1xuICAgIGNvbnN0IHsgZGF0YTogbWVtYmVycyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdncm91cF9nb2FsX21lbWJlcnMnKVxuICAgICAgLnNlbGVjdCgndXNlcl9pZCwgcHJvZmlsZTpwcm9maWxlcyhmaXJzdF9uYW1lLCBsYXN0X25hbWUsIHVzZXJuYW1lKScpXG4gICAgICAuZXEoJ2dvYWxfaWQnLCBnb2FsSWQpXG4gICAgICAuZXEoJ3N0YXR1cycsICdhY2NlcHRlZCcpXG5cbiAgICAvLyBHZXQgYWxsIGNvbXBsZXRpb25zXG4gICAgY29uc3QgeyBkYXRhOiBjb21wbGV0aW9ucyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdhY3Rpdml0eV9jb21wbGV0aW9ucycpXG4gICAgICAuc2VsZWN0KCdhY3Rpdml0eV9pZCwgdXNlcl9pZCcpXG4gICAgICAuZXEoJ2dvYWxfaWQnLCBnb2FsSWQpXG5cbiAgICBjb25zdCBtZW1iZXJQcm9ncmVzcyA9IG1lbWJlcnM/Lm1hcChtZW1iZXIgPT4ge1xuICAgICAgY29uc3QgYXNzaWduZWRBY3Rpdml0aWVzID0gYWN0aXZpdGllcy5maWx0ZXIoXG4gICAgICAgIGEgPT4gYS5hc3NpZ25lZF90b19hbGwgfHwgYS5hc3NpZ25lZF90byA9PT0gbWVtYmVyLnVzZXJfaWRcbiAgICAgIClcbiAgICAgIGNvbnN0IGNvbXBsZXRlZEFjdGl2aXRpZXMgPSBhc3NpZ25lZEFjdGl2aXRpZXMuZmlsdGVyKGEgPT5cbiAgICAgICAgY29tcGxldGlvbnM/LnNvbWUoYyA9PiBjLmFjdGl2aXR5X2lkID09PSBhLmlkICYmIGMudXNlcl9pZCA9PT0gbWVtYmVyLnVzZXJfaWQpXG4gICAgICApXG5cbiAgICAgIGNvbnN0IHByb2ZpbGUgPSBtZW1iZXIucHJvZmlsZSBhcyBhbnlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVzZXJfaWQ6IG1lbWJlci51c2VyX2lkLFxuICAgICAgICBuYW1lOiBwcm9maWxlID8gYCR7cHJvZmlsZS5maXJzdF9uYW1lIHx8ICcnfSAke3Byb2ZpbGUubGFzdF9uYW1lIHx8ICcnfWAudHJpbSgpIDogJ1Vua25vd24nLFxuICAgICAgICBhc3NpZ25lZDogYXNzaWduZWRBY3Rpdml0aWVzLmxlbmd0aCxcbiAgICAgICAgY29tcGxldGVkOiBjb21wbGV0ZWRBY3Rpdml0aWVzLmxlbmd0aCxcbiAgICAgICAgcHJvZ3Jlc3M6IGFzc2lnbmVkQWN0aXZpdGllcy5sZW5ndGggPiAwXG4gICAgICAgICAgPyBNYXRoLnJvdW5kKChjb21wbGV0ZWRBY3Rpdml0aWVzLmxlbmd0aCAvIGFzc2lnbmVkQWN0aXZpdGllcy5sZW5ndGgpICogMTAwKVxuICAgICAgICAgIDogMFxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBDYWxjdWxhdGUgb3ZlcmFsbCBwcm9ncmVzc1xuICAgIGNvbnN0IHRvdGFsQXNzaWduZWRBY3Rpdml0aWVzID0gbWVtYmVyUHJvZ3Jlc3M/LnJlZHVjZSgoc3VtLCBtZW1iZXIpID0+IHN1bSArIG1lbWJlci5hc3NpZ25lZCwgMCkgfHwgMFxuICAgIGNvbnN0IHRvdGFsQ29tcGxldGVkQWN0aXZpdGllcyA9IG1lbWJlclByb2dyZXNzPy5yZWR1Y2UoKHN1bSwgbWVtYmVyKSA9PiBzdW0gKyBtZW1iZXIuY29tcGxldGVkLCAwKSB8fCAwXG4gICAgY29uc3Qgb3ZlcmFsbFByb2dyZXNzID0gdG90YWxBc3NpZ25lZEFjdGl2aXRpZXMgPiAwIFxuICAgICAgPyBNYXRoLnJvdW5kKCh0b3RhbENvbXBsZXRlZEFjdGl2aXRpZXMgLyB0b3RhbEFzc2lnbmVkQWN0aXZpdGllcykgKiAxMDApXG4gICAgICA6IDBcblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHRvdGFsQWN0aXZpdGllczogYWN0aXZpdGllcy5sZW5ndGgsXG4gICAgICAgIGNvbXBsZXRlZEFjdGl2aXRpZXM6IGFjdGl2aXRpZXMuZmlsdGVyKGEgPT4gYS5jb21wbGV0ZWQpLmxlbmd0aCxcbiAgICAgICAgb3ZlcmFsbFByb2dyZXNzLFxuICAgICAgICBtZW1iZXJQcm9ncmVzc1xuICAgICAgfSxcbiAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvZ3Jlc3M6JywgZXJyb3IpXG4gICAgcmV0dXJuIHsgZXJyb3IsIHN1Y2Nlc3M6IGZhbHNlIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGFsbCBtZW1iZXJzIGhhdmUgcmVzcG9uZGVkIHRvIGdyb3VwIGdvYWwgaW52aXRhdGlvblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tBbGxNZW1iZXJzUmVzcG9uZGVkKGdvYWxJZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhOiBwZW5kaW5nTWVtYmVycyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdncm91cF9nb2FsX21lbWJlcnMnKVxuICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgLmVxKCdnb2FsX2lkJywgZ29hbElkKVxuICAgICAgLmVxKCdzdGF0dXMnLCAncGVuZGluZycpXG5cbiAgICByZXR1cm4gIXBlbmRpbmdNZW1iZXJzIHx8IHBlbmRpbmdNZW1iZXJzLmxlbmd0aCA9PT0gMFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIG1lbWJlciByZXNwb25zZXM6JywgZXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiB1c2VyIGNhbiB1cGRhdGUgZ3JvdXAgZ29hbCBwcm9ncmVzc1xuICogT25seSBhbGxvd2VkIGlmIGFsbCBtZW1iZXJzIGhhdmUgYWNjZXB0ZWQgb3IgZGVjbGluZWRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhblVwZGF0ZUdyb3VwR29hbFByb2dyZXNzKGdvYWxJZDogc3RyaW5nKTogUHJvbWlzZTx7IGNhblVwZGF0ZTogYm9vbGVhbjsgcmVhc29uPzogc3RyaW5nIH0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGE6IGdvYWwgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZ29hbHMnKVxuICAgICAgLnNlbGVjdCgnaXNfZ3JvdXBfZ29hbCcpXG4gICAgICAuZXEoJ2lkJywgZ29hbElkKVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICAvLyBOb3QgYSBncm91cCBnb2FsLCBjYW4gdXBkYXRlIGZyZWVseVxuICAgIGlmICghZ29hbD8uaXNfZ3JvdXBfZ29hbCkge1xuICAgICAgcmV0dXJuIHsgY2FuVXBkYXRlOiB0cnVlIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhbGwgbWVtYmVycyBoYXZlIHJlc3BvbmRlZFxuICAgIGNvbnN0IGFsbFJlc3BvbmRlZCA9IGF3YWl0IGNoZWNrQWxsTWVtYmVyc1Jlc3BvbmRlZChnb2FsSWQpXG4gICAgXG4gICAgaWYgKCFhbGxSZXNwb25kZWQpIHtcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBjYW5VcGRhdGU6IGZhbHNlLCBcbiAgICAgICAgcmVhc29uOiAnV2FpdGluZyBmb3IgYWxsIG1lbWJlcnMgdG8gYWNjZXB0IG9yIGRlY2xpbmUgdGhlIGludml0YXRpb24nIFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGF0IGxlYXN0IG9uZSBtZW1iZXIgYWNjZXB0ZWRcbiAgICBjb25zdCB7IGRhdGE6IGFjY2VwdGVkTWVtYmVycyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdncm91cF9nb2FsX21lbWJlcnMnKVxuICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgLmVxKCdnb2FsX2lkJywgZ29hbElkKVxuICAgICAgLmVxKCdzdGF0dXMnLCAnYWNjZXB0ZWQnKVxuXG4gICAgaWYgKCFhY2NlcHRlZE1lbWJlcnMgfHwgYWNjZXB0ZWRNZW1iZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FuVXBkYXRlOiBmYWxzZSxcbiAgICAgICAgcmVhc29uOiAnTm8gbWVtYmVycyBoYXZlIGFjY2VwdGVkIHRoaXMgZ3JvdXAgZ29hbCdcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBjYW5VcGRhdGU6IHRydWUgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHVwZGF0ZSBwZXJtaXNzaW9uOicsIGVycm9yKVxuICAgIHJldHVybiB7IGNhblVwZGF0ZTogZmFsc2UsIHJlYXNvbjogJ0Vycm9yIGNoZWNraW5nIHBlcm1pc3Npb25zJyB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYWN0aXZpdHkgcHJvZ3Jlc3MgZm9yIGEgc3BlY2lmaWMgYWN0aXZpdHlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFjdGl2aXR5UHJvZ3Jlc3MoYWN0aXZpdHlJZDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgLy8gR2V0IGFjdGl2aXR5IGRldGFpbHNcbiAgICBjb25zdCB7IGRhdGE6IGFjdGl2aXR5IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2dvYWxfYWN0aXZpdGllcycpXG4gICAgICAuc2VsZWN0KCcqLCBnb2FsX2lkJylcbiAgICAgIC5lcSgnaWQnLCBhY3Rpdml0eUlkKVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICBpZiAoIWFjdGl2aXR5KSB0aHJvdyBuZXcgRXJyb3IoJ0FjdGl2aXR5IG5vdCBmb3VuZCcpXG5cbiAgICAvLyBHZXQgYXNzaWduZWQgbWVtYmVyc1xuICAgIGxldCBhc3NpZ25lZE1lbWJlcnMgPSBbXVxuICAgIGlmIChhY3Rpdml0eS5hc3NpZ25lZF90b19hbGwpIHtcbiAgICAgIGNvbnN0IHsgZGF0YTogYWxsTWVtYmVycyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2dyb3VwX2dvYWxfbWVtYmVycycpXG4gICAgICAgIC5zZWxlY3QoJ3VzZXJfaWQsIHByb2ZpbGU6cHJvZmlsZXMoZmlyc3RfbmFtZSwgbGFzdF9uYW1lLCB1c2VybmFtZSwgcHJvZmlsZV9waWN0dXJlX3VybCknKVxuICAgICAgICAuZXEoJ2dvYWxfaWQnLCBhY3Rpdml0eS5nb2FsX2lkKVxuICAgICAgICAuZXEoJ3N0YXR1cycsICdhY2NlcHRlZCcpXG4gICAgICBhc3NpZ25lZE1lbWJlcnMgPSBhbGxNZW1iZXJzIHx8IFtdXG4gICAgfSBlbHNlIGlmIChhY3Rpdml0eS5hc3NpZ25lZF9tZW1iZXJzICYmIGFjdGl2aXR5LmFzc2lnbmVkX21lbWJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgeyBkYXRhOiBtdWx0aXBsZU1lbWJlcnMgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgIC5zZWxlY3QoJ2lkLCBmaXJzdF9uYW1lLCBsYXN0X25hbWUsIHVzZXJuYW1lLCBwcm9maWxlX3BpY3R1cmVfdXJsJylcbiAgICAgICAgLmluKCdpZCcsIGFjdGl2aXR5LmFzc2lnbmVkX21lbWJlcnMpXG4gICAgICBpZiAobXVsdGlwbGVNZW1iZXJzKSB7XG4gICAgICAgIGFzc2lnbmVkTWVtYmVycyA9IG11bHRpcGxlTWVtYmVycy5tYXAobWVtYmVyID0+ICh7IHVzZXJfaWQ6IG1lbWJlci5pZCwgcHJvZmlsZTogbWVtYmVyIH0pKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWN0aXZpdHkuYXNzaWduZWRfdG8pIHtcbiAgICAgIGNvbnN0IHsgZGF0YTogc3BlY2lmaWNNZW1iZXIgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgIC5zZWxlY3QoJ2lkLCBmaXJzdF9uYW1lLCBsYXN0X25hbWUsIHVzZXJuYW1lLCBwcm9maWxlX3BpY3R1cmVfdXJsJylcbiAgICAgICAgLmVxKCdpZCcsIGFjdGl2aXR5LmFzc2lnbmVkX3RvKVxuICAgICAgICAuc2luZ2xlKClcbiAgICAgIGlmIChzcGVjaWZpY01lbWJlcikge1xuICAgICAgICBhc3NpZ25lZE1lbWJlcnMgPSBbeyB1c2VyX2lkOiBzcGVjaWZpY01lbWJlci5pZCwgcHJvZmlsZTogc3BlY2lmaWNNZW1iZXIgfV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXQgY29tcGxldGlvbnNcbiAgICBjb25zdCB7IGRhdGE6IGNvbXBsZXRpb25zIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2FjdGl2aXR5X2NvbXBsZXRpb25zJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICAqLFxuICAgICAgICB1c2VyOnByb2ZpbGVzKGZpcnN0X25hbWUsIGxhc3RfbmFtZSwgdXNlcm5hbWUsIHByb2ZpbGVfcGljdHVyZV91cmwpXG4gICAgICBgKVxuICAgICAgLmVxKCdhY3Rpdml0eV9pZCcsIGFjdGl2aXR5SWQpXG4gICAgICAub3JkZXIoJ2NvbXBsZXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gICAgY29uc3QgY29tcGxldGVkVXNlcklkcyA9IG5ldyBTZXQoY29tcGxldGlvbnM/Lm1hcChjID0+IGMudXNlcl9pZCkgfHwgW10pXG4gICAgY29uc3QgcHJvZ3Jlc3NQZXJjZW50YWdlID0gYXNzaWduZWRNZW1iZXJzLmxlbmd0aCA+IDAgXG4gICAgICA/IE1hdGgucm91bmQoKGNvbXBsZXRpb25zPy5sZW5ndGggfHwgMCkgLyBhc3NpZ25lZE1lbWJlcnMubGVuZ3RoICogMTAwKVxuICAgICAgOiAwXG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YToge1xuICAgICAgICBhY3Rpdml0eSxcbiAgICAgICAgYXNzaWduZWRNZW1iZXJzLFxuICAgICAgICBjb21wbGV0aW9uczogY29tcGxldGlvbnMgfHwgW10sXG4gICAgICAgIHByb2dyZXNzUGVyY2VudGFnZSxcbiAgICAgICAgY29tcGxldGVkQ291bnQ6IGNvbXBsZXRpb25zPy5sZW5ndGggfHwgMCxcbiAgICAgICAgdG90YWxBc3NpZ25lZDogYXNzaWduZWRNZW1iZXJzLmxlbmd0aFxuICAgICAgfSxcbiAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYWN0aXZpdHkgcHJvZ3Jlc3M6JywgZXJyb3IpXG4gICAgcmV0dXJuIHsgZXJyb3IsIHN1Y2Nlc3M6IGZhbHNlIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbInN1cGFiYXNlIiwiY3JlYXRlR3JvdXBHb2FsIiwiZ29hbERhdGEiLCJtZW1iZXJJZHMiLCJkYXRhIiwidXNlciIsImF1dGgiLCJnZXRVc2VyIiwiRXJyb3IiLCJnb2FsIiwiZXJyb3IiLCJnb2FsRXJyb3IiLCJmcm9tIiwiaW5zZXJ0IiwidXNlcl9pZCIsImlkIiwiaXNfZ3JvdXBfZ29hbCIsImdyb3VwX2dvYWxfc3RhdHVzIiwic2VsZWN0Iiwic2luZ2xlIiwibWVtYmVyRXJyb3IiLCJnb2FsX2lkIiwicm9sZSIsInN0YXR1cyIsImNhbl9lZGl0IiwiY29uc29sZSIsImludml0YXRpb25zIiwibWFwIiwibWVtYmVySWQiLCJpbnZpdGVyX2lkIiwiaW52aXRlZV9pZCIsIm1lc3NhZ2UiLCJ0aXRsZSIsImludml0ZUVycm9yIiwicHJvZmlsZSIsImVxIiwidXNlck5hbWUiLCJmaXJzdF9uYW1lIiwibGFzdF9uYW1lIiwidHJpbSIsInVzZXJuYW1lIiwibm90aWZpY2F0aW9ucyIsInR5cGUiLCJpbnZpdGF0aW9uX3R5cGUiLCJhY3Rpb25fcmVxdWlyZWQiLCJyZWFkIiwibm90aWZFcnJvciIsInN1Y2Nlc3MiLCJnZXRQZW5kaW5nSW52aXRhdGlvbnMiLCJvcmRlciIsImFzY2VuZGluZyIsImFjY2VwdEdyb3VwR29hbEludml0YXRpb24iLCJpbnZpdGF0aW9uSWQiLCJpbnZpdGF0aW9uIiwidXBkYXRlIiwicmVzcG9uZGVkX2F0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidXBzZXJ0IiwiZGVjbGluZUdyb3VwR29hbEludml0YXRpb24iLCJnZXRHcm91cEdvYWxNZW1iZXJzIiwiZ29hbElkIiwiYXNzaWduQWN0aXZpdHkiLCJhY3Rpdml0eUlkIiwiYXNzaWdubWVudCIsInVwZGF0ZUFjdGl2aXR5QXNzaWdubWVudCIsImNvbXBsZXRlQWN0aXZpdHkiLCJub3RlcyIsImFjdGl2aXR5IiwiY2FuQ29tcGxldGUiLCJhc3NpZ25lZF90b19hbGwiLCJhc3NpZ25lZF90byIsImFzc2lnbmVkX21lbWJlcnMiLCJpbmNsdWRlcyIsImV4aXN0aW5nQ29tcGxldGlvbiIsImFjdGl2aXR5X2lkIiwibWVtYmVycyIsIm5lcSIsImxlbmd0aCIsInVzZXJQcm9maWxlIiwibWVtYmVyIiwiY29tcGxldGVkX2J5IiwiY29tcGxldGVkX2J5X25hbWUiLCJ1bmNvbXBsZXRlQWN0aXZpdHkiLCJjYW5FZGl0IiwiY2FuVXNlckVkaXRBY3Rpdml0eSIsImRlbGV0ZSIsImdldEFjdGl2aXR5Q29tcGxldGlvbnMiLCJjYW5Vc2VyVXBkYXRlQWN0aXZpdHkiLCJ1c2VySWQiLCJpc0dyb3VwR29hbEFkbWluIiwiaXNBZG1pbiIsImdldEdyb3VwR29hbERldGFpbHMiLCJtZW1iZXJzRXJyb3IiLCJhY3Rpdml0aWVzIiwiYWN0aXZpdGllc0Vycm9yIiwiY29tcGxldGlvbnMiLCJjb21wbGV0aW9uc0Vycm9yIiwiYXNzaWduZWRUbyIsImFzc2lnbmVkVG9BbGwiLCJhc3NpZ25lZE1lbWJlcnMiLCJhY3Rpdml0eV90eXBlIiwiZGVsZXRlR3JvdXBHb2FsIiwiYWRtaW5Qcm9maWxlIiwiYWRtaW5OYW1lIiwiZ29hbF90aXRsZSIsImRlbGV0ZWRfYnkiLCJkZWxldGVkX2J5X25hbWUiLCJ1cGRhdGVHcm91cEdvYWwiLCJ1cGRhdGVzIiwiZGVzY3JpcHRpb24iLCJ0YXJnZXRfZGF0ZSIsInVwZGF0ZWRfYnkiLCJ1cGRhdGVkX2J5X25hbWUiLCJnZXRHcm91cEdvYWxQcm9ncmVzcyIsIm1lbWJlclByb2dyZXNzIiwiYXNzaWduZWRBY3Rpdml0aWVzIiwiZmlsdGVyIiwiYSIsImNvbXBsZXRlZEFjdGl2aXRpZXMiLCJzb21lIiwiYyIsIm5hbWUiLCJhc3NpZ25lZCIsImNvbXBsZXRlZCIsInByb2dyZXNzIiwiTWF0aCIsInJvdW5kIiwidG90YWxBc3NpZ25lZEFjdGl2aXRpZXMiLCJyZWR1Y2UiLCJzdW0iLCJ0b3RhbENvbXBsZXRlZEFjdGl2aXRpZXMiLCJvdmVyYWxsUHJvZ3Jlc3MiLCJ0b3RhbEFjdGl2aXRpZXMiLCJjaGVja0FsbE1lbWJlcnNSZXNwb25kZWQiLCJwZW5kaW5nTWVtYmVycyIsImNhblVwZGF0ZUdyb3VwR29hbFByb2dyZXNzIiwiY2FuVXBkYXRlIiwiYWxsUmVzcG9uZGVkIiwicmVhc29uIiwiYWNjZXB0ZWRNZW1iZXJzIiwiZ2V0QWN0aXZpdHlQcm9ncmVzcyIsImFsbE1lbWJlcnMiLCJtdWx0aXBsZU1lbWJlcnMiLCJpbiIsInNwZWNpZmljTWVtYmVyIiwiY29tcGxldGVkVXNlcklkcyIsIlNldCIsInByb2dyZXNzUGVyY2VudGFnZSIsImNvbXBsZXRlZENvdW50IiwidG90YWxBc3NpZ25lZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/group-goals.ts\n"));

/***/ })

});