"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/goals/create/page",{

/***/ "(app-pages-browser)/./lib/group-goals.ts":
/*!****************************!*\
  !*** ./lib/group-goals.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   acceptGroupGoalInvitation: () => (/* binding */ acceptGroupGoalInvitation),\n/* harmony export */   assignActivity: () => (/* binding */ assignActivity),\n/* harmony export */   canUserEditActivity: () => (/* binding */ canUserEditActivity),\n/* harmony export */   canUserUpdateActivity: () => (/* binding */ canUserUpdateActivity),\n/* harmony export */   completeActivity: () => (/* binding */ completeActivity),\n/* harmony export */   createGroupGoal: () => (/* binding */ createGroupGoal),\n/* harmony export */   declineGroupGoalInvitation: () => (/* binding */ declineGroupGoalInvitation),\n/* harmony export */   deleteGroupGoal: () => (/* binding */ deleteGroupGoal),\n/* harmony export */   getActivityCompletions: () => (/* binding */ getActivityCompletions),\n/* harmony export */   getActivityProgress: () => (/* binding */ getActivityProgress),\n/* harmony export */   getGroupGoalDetails: () => (/* binding */ getGroupGoalDetails),\n/* harmony export */   getGroupGoalMembers: () => (/* binding */ getGroupGoalMembers),\n/* harmony export */   getGroupGoalProgress: () => (/* binding */ getGroupGoalProgress),\n/* harmony export */   getPendingInvitations: () => (/* binding */ getPendingInvitations),\n/* harmony export */   isGroupGoalAdmin: () => (/* binding */ isGroupGoalAdmin),\n/* harmony export */   uncompleteActivity: () => (/* binding */ uncompleteActivity),\n/* harmony export */   updateActivityAssignment: () => (/* binding */ updateActivityAssignment),\n/* harmony export */   updateGroupGoal: () => (/* binding */ updateGroupGoal)\n/* harmony export */ });\n/* harmony import */ var _supabase_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase-client */ \"(app-pages-browser)/./lib/supabase-client.ts\");\n/**\n * Group Goals Service\n * Handles all group goal operations including invitations, member management, and activity assignments\n */ \n/**\n * Create a group goal with initial members\n */ async function createGroupGoal(goalData, memberIds) {\n    try {\n        const { data: { user } } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) throw new Error('Not authenticated');\n        // Create the goal\n        const { data: goal, error: goalError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goals').insert({\n            ...goalData,\n            user_id: user.id,\n            is_group_goal: true,\n            group_goal_status: 'pending'\n        }).select().single();\n        if (goalError) throw goalError;\n        // Add owner as accepted member\n        const { error: memberError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').insert({\n            goal_id: goal.id,\n            user_id: user.id,\n            role: 'owner',\n            status: 'accepted',\n            can_edit: true\n        });\n        if (memberError) {\n            console.error('Error adding owner as member:', memberError);\n        }\n        // Send invitations to members\n        const invitations = memberIds.map((memberId)=>({\n                goal_id: goal.id,\n                inviter_id: user.id,\n                invitee_id: memberId,\n                status: 'pending',\n                message: \"Join our group goal: \".concat(goalData.title)\n            }));\n        const { error: inviteError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_invitations').insert(invitations);\n        if (inviteError) throw inviteError;\n        // Create notifications for invitees\n        const { data: profile } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('profiles').select('first_name, last_name, username').eq('id', user.id).single();\n        const userName = profile ? \"\".concat(profile.first_name, \" \").concat(profile.last_name).trim() || profile.username : 'Someone';\n        // Insert notifications with proper structure for Commitly\n        const notifications = memberIds.map((memberId)=>({\n                user_id: memberId,\n                type: 'accountability_request',\n                title: 'Group Goal Invitation ðŸŽ¯',\n                message: \"\".concat(userName, ' invited you to join the group goal: \"').concat(goal.title, '\"'),\n                data: {\n                    goal_id: goal.id,\n                    inviter_id: user.id,\n                    invitation_type: 'group_goal',\n                    action_required: true\n                },\n                read: false\n            }));\n        const { error: notifError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('notifications').insert(notifications);\n        if (notifError) console.error('Notification error:', notifError);\n        return {\n            goal,\n            success: true\n        };\n    } catch (error) {\n        console.error('Error creating group goal:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Get pending invitations for current user\n */ async function getPendingInvitations() {\n    try {\n        const { data: { user } } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) throw new Error('Not authenticated');\n        const { data, error } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_invitations').select(\"\\n        *,\\n        goal:goals(title, description, category),\\n        inviter:profiles!group_goal_invitations_inviter_id_fkey(\\n          first_name, last_name, username, profile_picture_url\\n        )\\n      \").eq('invitee_id', user.id).eq('status', 'pending').order('created_at', {\n            ascending: false\n        });\n        if (error) throw error;\n        return {\n            data,\n            success: true\n        };\n    } catch (error) {\n        console.error('Error fetching invitations:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Accept group goal invitation\n */ async function acceptGroupGoalInvitation(invitationId) {\n    try {\n        const { data: { user } } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) throw new Error('Not authenticated');\n        const { error } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_invitations').update({\n            status: 'accepted',\n            responded_at: new Date().toISOString()\n        }).eq('id', invitationId).eq('invitee_id', user.id);\n        if (error) throw error;\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error('Error accepting invitation:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Decline group goal invitation\n */ async function declineGroupGoalInvitation(invitationId) {\n    try {\n        const { data: { user } } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) throw new Error('Not authenticated');\n        const { error } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_invitations').update({\n            status: 'declined',\n            responded_at: new Date().toISOString()\n        }).eq('id', invitationId).eq('invitee_id', user.id);\n        if (error) throw error;\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error('Error declining invitation:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Get group goal members\n */ async function getGroupGoalMembers(goalId) {\n    try {\n        const { data, error } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').select(\"\\n        *,\\n        profile:profiles(first_name, last_name, username, profile_picture_url)\\n      \").eq('goal_id', goalId).order('created_at', {\n            ascending: true\n        });\n        if (error) throw error;\n        return {\n            data,\n            success: true\n        };\n    } catch (error) {\n        console.error('Error fetching members:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Assign activity to user(s) (deprecated - use updateActivityAssignment)\n */ async function assignActivity(activityId, assignment) {\n    return updateActivityAssignment(activityId, assignment);\n}\n/**\n * Complete activity for current user\n */ async function completeActivity(activityId, goalId, notes) {\n    try {\n        const { data: { user } } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) throw new Error('Not authenticated');\n        // Check if activity is assigned to this user\n        const { data: activity } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goal_activities').select('assigned_to, assigned_to_all, assigned_members, title').eq('id', activityId).single();\n        if (!activity) throw new Error('Activity not found');\n        // Verify user can complete this activity\n        const canComplete = activity.assigned_to_all || activity.assigned_to === user.id || activity.assigned_members && activity.assigned_members.includes(user.id);\n        if (!canComplete) {\n            throw new Error('You are not assigned to this activity');\n        }\n        // Check if already completed by this user\n        const { data: existingCompletion } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('activity_completions').select('id').eq('activity_id', activityId).eq('user_id', user.id).single();\n        if (existingCompletion) {\n            throw new Error('Activity already completed by you');\n        }\n        // Insert completion record\n        const { error } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('activity_completions').insert({\n            activity_id: activityId,\n            user_id: user.id,\n            goal_id: goalId,\n            notes\n        });\n        if (error) throw error;\n        // Notify other group members\n        const { data: members } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').select('user_id').eq('goal_id', goalId).eq('status', 'accepted').neq('user_id', user.id);\n        if (members && members.length > 0) {\n            const { data: userProfile } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('profiles').select('first_name, last_name, username').eq('id', user.id).single();\n            const userName = userProfile ? \"\".concat(userProfile.first_name, \" \").concat(userProfile.last_name).trim() || userProfile.username : 'Someone';\n            const notifications = members.map((member)=>({\n                    user_id: member.user_id,\n                    type: 'activity_completed',\n                    title: 'Activity Completed! ðŸŽ‰',\n                    message: \"\".concat(userName, ' completed: \"').concat(activity.title, '\"'),\n                    data: {\n                        activity_id: activityId,\n                        goal_id: goalId,\n                        completed_by: user.id,\n                        completed_by_name: userName\n                    },\n                    read: false\n                }));\n            await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('notifications').insert(notifications);\n        }\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error('Error completing activity:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Uncomplete activity for current user (remove completion)\n */ async function uncompleteActivity(activityId, goalId) {\n    try {\n        const { data: { user } } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) throw new Error('Not authenticated');\n        // Check if user can edit this activity\n        const canEdit = await canUserEditActivity(activityId, user.id);\n        if (!canEdit) {\n            throw new Error('You cannot uncomplete this activity');\n        }\n        // Remove completion record\n        const { error } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('activity_completions').delete().eq('activity_id', activityId).eq('user_id', user.id);\n        if (error) throw error;\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error('Error uncompleting activity:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Get activity completion status for group goal\n */ async function getActivityCompletions(activityId) {\n    try {\n        const { data, error } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('activity_completions').select(\"\\n        *,\\n        user:profiles(first_name, last_name, username, profile_picture_url)\\n      \").eq('activity_id', activityId).order('completed_at', {\n            ascending: false\n        });\n        if (error) throw error;\n        return {\n            data,\n            success: true\n        };\n    } catch (error) {\n        console.error('Error fetching completions:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Check if user can update activity (deprecated - use canUserEditActivity)\n */ async function canUserUpdateActivity(activityId, userId) {\n    return canUserEditActivity(activityId, userId);\n}\n/**\n * Check if user is admin (owner) of a group goal\n */ async function isGroupGoalAdmin(goalId, userId) {\n    try {\n        // Check if user is the goal owner\n        const { data: goal } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goals').select('user_id, is_group_goal').eq('id', goalId).single();\n        if (!goal) return false;\n        // For group goals, check if user is the owner\n        if (goal.is_group_goal) {\n            return goal.user_id === userId;\n        }\n        // For regular goals, only owner can manage\n        return goal.user_id === userId;\n    } catch (error) {\n        console.error('Error checking admin permissions:', error);\n        return false;\n    }\n}\n/**\n * Check if user can edit a specific activity\n */ async function canUserEditActivity(activityId, userId) {\n    try {\n        const { data: activity } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goal_activities').select('assigned_to, assigned_to_all, assigned_members, goal_id').eq('id', activityId).single();\n        if (!activity) return false;\n        // Check if user is goal admin first\n        const isAdmin = await isGroupGoalAdmin(activity.goal_id, userId);\n        if (isAdmin) return true;\n        // Check if activity is assigned to this user\n        if (activity.assigned_to_all) return true;\n        if (activity.assigned_to === userId) return true;\n        if (activity.assigned_members && activity.assigned_members.includes(userId)) return true;\n        return false;\n    } catch (error) {\n        console.error('Error checking activity edit permissions:', error);\n        return false;\n    }\n}\n/**\n * Get detailed group goal with members and activities\n */ async function getGroupGoalDetails(goalId) {\n    try {\n        // Get goal details\n        const { data: goal, error: goalError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goals').select('*').eq('id', goalId).single();\n        if (goalError) throw goalError;\n        // Get members\n        const { data: members, error: membersError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').select(\"\\n        *,\\n        profile:profiles(first_name, last_name, username, profile_picture_url)\\n      \").eq('goal_id', goalId).order('created_at', {\n            ascending: true\n        });\n        if (membersError) throw membersError;\n        // Get activities with assignments\n        const { data: activities, error: activitiesError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goal_activities').select('*').eq('goal_id', goalId).order('order_index', {\n            ascending: true\n        });\n        if (activitiesError) throw activitiesError;\n        // Get activity completions\n        const { data: completions, error: completionsError } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('activity_completions').select(\"\\n        *,\\n        user:profiles(first_name, last_name, username, profile_picture_url)\\n      \").eq('goal_id', goalId).order('completed_at', {\n            ascending: false\n        });\n        if (completionsError) throw completionsError;\n        return {\n            data: {\n                goal,\n                members: members || [],\n                activities: activities || [],\n                completions: completions || []\n            },\n            success: true\n        };\n    } catch (error) {\n        console.error('Error fetching group goal details:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Update activity assignment (admin only)\n */ async function updateActivityAssignment(activityId, assignment) {\n    try {\n        var _assignment_assignedMembers;\n        const { data: { user } } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) throw new Error('Not authenticated');\n        // Get activity to check permissions\n        const { data: activity } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goal_activities').select('goal_id').eq('id', activityId).single();\n        if (!activity) throw new Error('Activity not found');\n        // Check if user is admin\n        const isAdmin = await isGroupGoalAdmin(activity.goal_id, user.id);\n        if (!isAdmin) {\n            throw new Error('Only admins can update activity assignments');\n        }\n        const { error } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goal_activities').update({\n            assigned_to: assignment.assignedTo || null,\n            assigned_to_all: assignment.assignedToAll,\n            assigned_members: assignment.assignedMembers || null,\n            activity_type: assignment.assignedToAll ? 'collaborative' : ((_assignment_assignedMembers = assignment.assignedMembers) === null || _assignment_assignedMembers === void 0 ? void 0 : _assignment_assignedMembers.length) ? 'multi_member' : 'individual'\n        }).eq('id', activityId);\n        if (error) throw error;\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error('Error updating activity assignment:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Delete group goal (admin only)\n */ async function deleteGroupGoal(goalId) {\n    try {\n        const { data: { user } } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) throw new Error('Not authenticated');\n        // Check if user is admin\n        const isAdmin = await isGroupGoalAdmin(goalId, user.id);\n        if (!isAdmin) {\n            throw new Error('Only the goal admin can delete this goal');\n        }\n        // Get goal details for notifications\n        const { data: goal } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goals').select('title').eq('id', goalId).single();\n        // Get all members to notify them\n        const { data: members } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').select('user_id, profile:profiles(first_name, last_name)').eq('goal_id', goalId).eq('status', 'accepted').neq('user_id', user.id) // Exclude the admin\n        ;\n        // Delete the goal (cascade will handle related records)\n        const { error } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goals').delete().eq('id', goalId);\n        if (error) throw error;\n        // Notify all members about goal deletion\n        if (members && members.length > 0 && goal) {\n            const { data: adminProfile } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('profiles').select('first_name, last_name, username').eq('id', user.id).single();\n            const adminName = adminProfile ? \"\".concat(adminProfile.first_name, \" \").concat(adminProfile.last_name).trim() || adminProfile.username : 'Admin';\n            const notifications = members.map((member)=>({\n                    user_id: member.user_id,\n                    type: 'goal_deleted',\n                    title: 'Group Goal Deleted',\n                    message: \"\".concat(adminName, ' deleted the group goal: \"').concat(goal.title, '\"'),\n                    data: {\n                        goal_id: goalId,\n                        goal_title: goal.title,\n                        deleted_by: user.id,\n                        deleted_by_name: adminName\n                    },\n                    read: false\n                }));\n            await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('notifications').insert(notifications);\n        }\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error('Error deleting group goal:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Update group goal (admin only)\n */ async function updateGroupGoal(goalId, updates) {\n    try {\n        const { data: { user } } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) throw new Error('Not authenticated');\n        // Check if user is admin\n        const isAdmin = await isGroupGoalAdmin(goalId, user.id);\n        if (!isAdmin) {\n            throw new Error('Only the goal admin can edit this goal');\n        }\n        const { error } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goals').update(updates).eq('id', goalId);\n        if (error) throw error;\n        // If significant changes, notify members\n        if (updates.title || updates.description || updates.target_date) {\n            const { data: members } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').select('user_id').eq('goal_id', goalId).eq('status', 'accepted').neq('user_id', user.id);\n            if (members && members.length > 0) {\n                const { data: adminProfile } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('profiles').select('first_name, last_name, username').eq('id', user.id).single();\n                const adminName = adminProfile ? \"\".concat(adminProfile.first_name, \" \").concat(adminProfile.last_name).trim() || adminProfile.username : 'Admin';\n                const notifications = members.map((member)=>({\n                        user_id: member.user_id,\n                        type: 'goal_updated',\n                        title: 'Group Goal Updated',\n                        message: \"\".concat(adminName, \" updated the group goal details\"),\n                        data: {\n                            goal_id: goalId,\n                            updated_by: user.id,\n                            updated_by_name: adminName\n                        },\n                        read: false\n                    }));\n                await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('notifications').insert(notifications);\n            }\n        }\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error('Error updating group goal:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Get group goal progress with member stats\n */ async function getGroupGoalProgress(goalId) {\n    try {\n        // Get all activities\n        const { data: activities } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goal_activities').select('id, title, assigned_to, assigned_to_all, completed').eq('goal_id', goalId);\n        if (!activities) return {\n            data: null,\n            success: false\n        };\n        // Get all accepted members\n        const { data: members } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').select('user_id, profile:profiles(first_name, last_name, username)').eq('goal_id', goalId).eq('status', 'accepted');\n        // Get all completions\n        const { data: completions } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('activity_completions').select('activity_id, user_id').eq('goal_id', goalId);\n        const memberProgress = members === null || members === void 0 ? void 0 : members.map((member)=>{\n            const assignedActivities = activities.filter((a)=>a.assigned_to_all || a.assigned_to === member.user_id);\n            const completedActivities = assignedActivities.filter((a)=>completions === null || completions === void 0 ? void 0 : completions.some((c)=>c.activity_id === a.id && c.user_id === member.user_id));\n            const profile = member.profile;\n            return {\n                user_id: member.user_id,\n                name: profile ? \"\".concat(profile.first_name || '', \" \").concat(profile.last_name || '').trim() : 'Unknown',\n                assigned: assignedActivities.length,\n                completed: completedActivities.length,\n                progress: assignedActivities.length > 0 ? Math.round(completedActivities.length / assignedActivities.length * 100) : 0\n            };\n        });\n        // Calculate overall progress\n        const totalAssignedActivities = (memberProgress === null || memberProgress === void 0 ? void 0 : memberProgress.reduce((sum, member)=>sum + member.assigned, 0)) || 0;\n        const totalCompletedActivities = (memberProgress === null || memberProgress === void 0 ? void 0 : memberProgress.reduce((sum, member)=>sum + member.completed, 0)) || 0;\n        const overallProgress = totalAssignedActivities > 0 ? Math.round(totalCompletedActivities / totalAssignedActivities * 100) : 0;\n        return {\n            data: {\n                totalActivities: activities.length,\n                completedActivities: activities.filter((a)=>a.completed).length,\n                overallProgress,\n                memberProgress\n            },\n            success: true\n        };\n    } catch (error) {\n        console.error('Error fetching progress:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n/**\n * Get activity progress for a specific activity\n */ async function getActivityProgress(activityId) {\n    try {\n        // Get activity details\n        const { data: activity } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('goal_activities').select('*, goal_id').eq('id', activityId).single();\n        if (!activity) throw new Error('Activity not found');\n        // Get assigned members\n        let assignedMembers = [];\n        if (activity.assigned_to_all) {\n            const { data: allMembers } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('group_goal_members').select('user_id, profile:profiles(first_name, last_name, username, profile_picture_url)').eq('goal_id', activity.goal_id).eq('status', 'accepted');\n            assignedMembers = allMembers || [];\n        } else if (activity.assigned_members && activity.assigned_members.length > 0) {\n            const { data: multipleMembers } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('profiles').select('id, first_name, last_name, username, profile_picture_url').in('id', activity.assigned_members);\n            if (multipleMembers) {\n                assignedMembers = multipleMembers.map((member)=>({\n                        user_id: member.id,\n                        profile: member\n                    }));\n            }\n        } else if (activity.assigned_to) {\n            const { data: specificMember } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('profiles').select('id, first_name, last_name, username, profile_picture_url').eq('id', activity.assigned_to).single();\n            if (specificMember) {\n                assignedMembers = [\n                    {\n                        user_id: specificMember.id,\n                        profile: specificMember\n                    }\n                ];\n            }\n        }\n        // Get completions\n        const { data: completions } = await _supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('activity_completions').select(\"\\n        *,\\n        user:profiles(first_name, last_name, username, profile_picture_url)\\n      \").eq('activity_id', activityId).order('completed_at', {\n            ascending: false\n        });\n        const completedUserIds = new Set((completions === null || completions === void 0 ? void 0 : completions.map((c)=>c.user_id)) || []);\n        const progressPercentage = assignedMembers.length > 0 ? Math.round(((completions === null || completions === void 0 ? void 0 : completions.length) || 0) / assignedMembers.length * 100) : 0;\n        return {\n            data: {\n                activity,\n                assignedMembers,\n                completions: completions || [],\n                progressPercentage,\n                completedCount: (completions === null || completions === void 0 ? void 0 : completions.length) || 0,\n                totalAssigned: assignedMembers.length\n            },\n            success: true\n        };\n    } catch (error) {\n        console.error('Error fetching activity progress:', error);\n        return {\n            error,\n            success: false\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE1BQU07WUFDVCxJQUFJcUgsZ0JBQWdCO2dCQUNsQnRDLGtCQUFrQjtvQkFBQzt3QkFBRXBGLFNBQVMwSCxlQUFlekgsRUFBRTt3QkFBRW1CLFNBQVNzRztvQkFBZTtpQkFBRTtZQUM3RTtRQUNGO1FBRUEsa0JBQWtCO1FBQ2xCLE1BQU0sRUFBRXBJLE1BQU0wRixXQUFXLEVBQUUsR0FBRyxNQUFNOUYsc0RBQVFBLENBQ3pDWSxJQUFJLENBQUMsd0JBQ0xNLE1BQU0sQ0FBRSxxR0FJUmlCLEVBQUUsQ0FBQyxlQUFlMEIsWUFDbEJaLEtBQUssQ0FBQyxnQkFBZ0I7WUFBRUMsV0FBVztRQUFNO1FBRTVDLE1BQU11RixtQkFBbUIsSUFBSUMsSUFBSTVDLENBQUFBLHdCQUFBQSxrQ0FBQUEsWUFBYW5FLEdBQUcsQ0FBQzRGLENBQUFBLElBQUtBLEVBQUV6RyxPQUFPLE1BQUssRUFBRTtRQUN2RSxNQUFNNkgscUJBQXFCekMsZ0JBQWdCdEIsTUFBTSxHQUFHLElBQ2hEZ0QsS0FBS0MsS0FBSyxDQUFDLENBQUMvQixDQUFBQSx3QkFBQUEsa0NBQUFBLFlBQWFsQixNQUFNLEtBQUksS0FBS3NCLGdCQUFnQnRCLE1BQU0sR0FBRyxPQUNqRTtRQUVKLE9BQU87WUFDTHhFLE1BQU07Z0JBQ0o4RDtnQkFDQWdDO2dCQUNBSixhQUFhQSxlQUFlLEVBQUU7Z0JBQzlCNkM7Z0JBQ0FDLGdCQUFnQjlDLENBQUFBLHdCQUFBQSxrQ0FBQUEsWUFBYWxCLE1BQU0sS0FBSTtnQkFDdkNpRSxlQUFlM0MsZ0JBQWdCdEIsTUFBTTtZQUN2QztZQUNBN0IsU0FBUztRQUNYO0lBQ0YsRUFBRSxPQUFPckMsT0FBTztRQUNkZSxRQUFRZixLQUFLLENBQUMscUNBQXFDQTtRQUNuRCxPQUFPO1lBQUVBO1lBQU9xQyxTQUFTO1FBQU07SUFDakM7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxtZ2lmdFxcT25lRHJpdmVcXERlc2t0b3BcXENvbW1pdGx5XFxDb21taXRseVxcZnJvbnRlbmRcXGxpYlxcZ3JvdXAtZ29hbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHcm91cCBHb2FscyBTZXJ2aWNlXG4gKiBIYW5kbGVzIGFsbCBncm91cCBnb2FsIG9wZXJhdGlvbnMgaW5jbHVkaW5nIGludml0YXRpb25zLCBtZW1iZXIgbWFuYWdlbWVudCwgYW5kIGFjdGl2aXR5IGFzc2lnbm1lbnRzXG4gKi9cblxuaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICcuL3N1cGFiYXNlLWNsaWVudCdcblxuZXhwb3J0IGludGVyZmFjZSBHcm91cEdvYWxNZW1iZXIge1xuICBpZDogc3RyaW5nXG4gIGdvYWxfaWQ6IHN0cmluZ1xuICB1c2VyX2lkOiBzdHJpbmdcbiAgcm9sZTogJ293bmVyJyB8ICdtZW1iZXInXG4gIHN0YXR1czogJ3BlbmRpbmcnIHwgJ2FjY2VwdGVkJyB8ICdkZWNsaW5lZCdcbiAgaW52aXRlZF9hdDogc3RyaW5nXG4gIHJlc3BvbmRlZF9hdD86IHN0cmluZ1xuICBjYW5fZWRpdDogYm9vbGVhblxuICBwcm9maWxlPzoge1xuICAgIGZpcnN0X25hbWU6IHN0cmluZ1xuICAgIGxhc3RfbmFtZTogc3RyaW5nXG4gICAgdXNlcm5hbWU6IHN0cmluZ1xuICAgIHByb2ZpbGVfcGljdHVyZV91cmw/OiBzdHJpbmdcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyb3VwR29hbEludml0YXRpb24ge1xuICBpZDogc3RyaW5nXG4gIGdvYWxfaWQ6IHN0cmluZ1xuICBpbnZpdGVyX2lkOiBzdHJpbmdcbiAgaW52aXRlZV9pZDogc3RyaW5nXG4gIHN0YXR1czogJ3BlbmRpbmcnIHwgJ2FjY2VwdGVkJyB8ICdkZWNsaW5lZCcgfCAnY2FuY2VsbGVkJ1xuICBtZXNzYWdlPzogc3RyaW5nXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xuICByZXNwb25kZWRfYXQ/OiBzdHJpbmdcbiAgZ29hbD86IHtcbiAgICB0aXRsZTogc3RyaW5nXG4gICAgZGVzY3JpcHRpb246IHN0cmluZ1xuICB9XG4gIGludml0ZXI/OiB7XG4gICAgZmlyc3RfbmFtZTogc3RyaW5nXG4gICAgbGFzdF9uYW1lOiBzdHJpbmdcbiAgICB1c2VybmFtZTogc3RyaW5nXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBY3Rpdml0eUFzc2lnbm1lbnQge1xuICBhY3Rpdml0eV9pZDogc3RyaW5nXG4gIGFzc2lnbmVkX3RvPzogc3RyaW5nIC8vIHNwZWNpZmljIHVzZXIgSURcbiAgYXNzaWduZWRfdG9fYWxsOiBib29sZWFuXG4gIGFjdGl2aXR5X3R5cGU6ICdpbmRpdmlkdWFsJyB8ICdjb2xsYWJvcmF0aXZlJ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFjdGl2aXR5Q29tcGxldGlvbiB7XG4gIGlkOiBzdHJpbmdcbiAgYWN0aXZpdHlfaWQ6IHN0cmluZ1xuICB1c2VyX2lkOiBzdHJpbmdcbiAgZ29hbF9pZDogc3RyaW5nXG4gIGNvbXBsZXRlZF9hdDogc3RyaW5nXG4gIG5vdGVzPzogc3RyaW5nXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZ3JvdXAgZ29hbCB3aXRoIGluaXRpYWwgbWVtYmVyc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlR3JvdXBHb2FsKFxuICBnb2FsRGF0YToge1xuICAgIHRpdGxlOiBzdHJpbmdcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gICAgZ29hbF90eXBlOiBzdHJpbmdcbiAgICBjYXRlZ29yeT86IHN0cmluZ1xuICAgIHByaW9yaXR5Pzogc3RyaW5nXG4gICAgdmlzaWJpbGl0eTogc3RyaW5nXG4gIH0sXG4gIG1lbWJlcklkczogc3RyaW5nW11cbikge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpXG4gICAgaWYgKCF1c2VyKSB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdXRoZW50aWNhdGVkJylcblxuICAgIC8vIENyZWF0ZSB0aGUgZ29hbFxuICAgIGNvbnN0IHsgZGF0YTogZ29hbCwgZXJyb3I6IGdvYWxFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdnb2FscycpXG4gICAgICAuaW5zZXJ0KHtcbiAgICAgICAgLi4uZ29hbERhdGEsXG4gICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgIGlzX2dyb3VwX2dvYWw6IHRydWUsXG4gICAgICAgIGdyb3VwX2dvYWxfc3RhdHVzOiAncGVuZGluZydcbiAgICAgIH0pXG4gICAgICAuc2VsZWN0KClcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgaWYgKGdvYWxFcnJvcikgdGhyb3cgZ29hbEVycm9yXG5cbiAgICAvLyBBZGQgb3duZXIgYXMgYWNjZXB0ZWQgbWVtYmVyXG4gICAgY29uc3QgeyBlcnJvcjogbWVtYmVyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2dyb3VwX2dvYWxfbWVtYmVycycpLmluc2VydCh7XG4gICAgICBnb2FsX2lkOiBnb2FsLmlkLFxuICAgICAgdXNlcl9pZDogdXNlci5pZCxcbiAgICAgIHJvbGU6ICdvd25lcicsXG4gICAgICBzdGF0dXM6ICdhY2NlcHRlZCcsXG4gICAgICBjYW5fZWRpdDogdHJ1ZVxuICAgIH0pXG4gICAgXG4gICAgaWYgKG1lbWJlckVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgb3duZXIgYXMgbWVtYmVyOicsIG1lbWJlckVycm9yKVxuICAgIH1cblxuICAgIC8vIFNlbmQgaW52aXRhdGlvbnMgdG8gbWVtYmVyc1xuICAgIGNvbnN0IGludml0YXRpb25zID0gbWVtYmVySWRzLm1hcChtZW1iZXJJZCA9PiAoe1xuICAgICAgZ29hbF9pZDogZ29hbC5pZCxcbiAgICAgIGludml0ZXJfaWQ6IHVzZXIuaWQsXG4gICAgICBpbnZpdGVlX2lkOiBtZW1iZXJJZCxcbiAgICAgIHN0YXR1czogJ3BlbmRpbmcnIGFzIGNvbnN0LFxuICAgICAgbWVzc2FnZTogYEpvaW4gb3VyIGdyb3VwIGdvYWw6ICR7Z29hbERhdGEudGl0bGV9YFxuICAgIH0pKVxuXG4gICAgY29uc3QgeyBlcnJvcjogaW52aXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZ3JvdXBfZ29hbF9pbnZpdGF0aW9ucycpXG4gICAgICAuaW5zZXJ0KGludml0YXRpb25zKVxuXG4gICAgaWYgKGludml0ZUVycm9yKSB0aHJvdyBpbnZpdGVFcnJvclxuXG4gICAgLy8gQ3JlYXRlIG5vdGlmaWNhdGlvbnMgZm9yIGludml0ZWVzXG4gICAgY29uc3QgeyBkYXRhOiBwcm9maWxlIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgIC5zZWxlY3QoJ2ZpcnN0X25hbWUsIGxhc3RfbmFtZSwgdXNlcm5hbWUnKVxuICAgICAgLmVxKCdpZCcsIHVzZXIuaWQpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGNvbnN0IHVzZXJOYW1lID0gcHJvZmlsZSBcbiAgICAgID8gYCR7cHJvZmlsZS5maXJzdF9uYW1lfSAke3Byb2ZpbGUubGFzdF9uYW1lfWAudHJpbSgpIHx8IHByb2ZpbGUudXNlcm5hbWVcbiAgICAgIDogJ1NvbWVvbmUnXG5cbiAgICAvLyBJbnNlcnQgbm90aWZpY2F0aW9ucyB3aXRoIHByb3BlciBzdHJ1Y3R1cmUgZm9yIENvbW1pdGx5XG4gICAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IG1lbWJlcklkcy5tYXAobWVtYmVySWQgPT4gKHtcbiAgICAgIHVzZXJfaWQ6IG1lbWJlcklkLFxuICAgICAgdHlwZTogJ2FjY291bnRhYmlsaXR5X3JlcXVlc3QnLCAvLyBVc2UgZXhpc3Rpbmcgbm90aWZpY2F0aW9uIHR5cGVcbiAgICAgIHRpdGxlOiAnR3JvdXAgR29hbCBJbnZpdGF0aW9uIPCfjq8nLFxuICAgICAgbWVzc2FnZTogYCR7dXNlck5hbWV9IGludml0ZWQgeW91IHRvIGpvaW4gdGhlIGdyb3VwIGdvYWw6IFwiJHtnb2FsLnRpdGxlfVwiYCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZ29hbF9pZDogZ29hbC5pZCxcbiAgICAgICAgaW52aXRlcl9pZDogdXNlci5pZCxcbiAgICAgICAgaW52aXRhdGlvbl90eXBlOiAnZ3JvdXBfZ29hbCcsXG4gICAgICAgIGFjdGlvbl9yZXF1aXJlZDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHJlYWQ6IGZhbHNlXG4gICAgfSkpXG5cbiAgICBjb25zdCB7IGVycm9yOiBub3RpZkVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdub3RpZmljYXRpb25zJykuaW5zZXJ0KG5vdGlmaWNhdGlvbnMpXG4gICAgaWYgKG5vdGlmRXJyb3IpIGNvbnNvbGUuZXJyb3IoJ05vdGlmaWNhdGlvbiBlcnJvcjonLCBub3RpZkVycm9yKVxuXG4gICAgcmV0dXJuIHsgZ29hbCwgc3VjY2VzczogdHJ1ZSB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgZ3JvdXAgZ29hbDonLCBlcnJvcilcbiAgICByZXR1cm4geyBlcnJvciwgc3VjY2VzczogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IHBlbmRpbmcgaW52aXRhdGlvbnMgZm9yIGN1cnJlbnQgdXNlclxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGVuZGluZ0ludml0YXRpb25zKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpXG4gICAgaWYgKCF1c2VyKSB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdXRoZW50aWNhdGVkJylcblxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZ3JvdXBfZ29hbF9pbnZpdGF0aW9ucycpXG4gICAgICAuc2VsZWN0KGBcbiAgICAgICAgKixcbiAgICAgICAgZ29hbDpnb2Fscyh0aXRsZSwgZGVzY3JpcHRpb24sIGNhdGVnb3J5KSxcbiAgICAgICAgaW52aXRlcjpwcm9maWxlcyFncm91cF9nb2FsX2ludml0YXRpb25zX2ludml0ZXJfaWRfZmtleShcbiAgICAgICAgICBmaXJzdF9uYW1lLCBsYXN0X25hbWUsIHVzZXJuYW1lLCBwcm9maWxlX3BpY3R1cmVfdXJsXG4gICAgICAgIClcbiAgICAgIGApXG4gICAgICAuZXEoJ2ludml0ZWVfaWQnLCB1c2VyLmlkKVxuICAgICAgLmVxKCdzdGF0dXMnLCAncGVuZGluZycpXG4gICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICByZXR1cm4geyBkYXRhLCBzdWNjZXNzOiB0cnVlIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBpbnZpdGF0aW9uczonLCBlcnJvcilcbiAgICByZXR1cm4geyBlcnJvciwgc3VjY2VzczogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0IGdyb3VwIGdvYWwgaW52aXRhdGlvblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWNjZXB0R3JvdXBHb2FsSW52aXRhdGlvbihpbnZpdGF0aW9uSWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpXG4gICAgaWYgKCF1c2VyKSB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdXRoZW50aWNhdGVkJylcblxuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZ3JvdXBfZ29hbF9pbnZpdGF0aW9ucycpXG4gICAgICAudXBkYXRlKHtcbiAgICAgICAgc3RhdHVzOiAnYWNjZXB0ZWQnLFxuICAgICAgICByZXNwb25kZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSlcbiAgICAgIC5lcSgnaWQnLCBpbnZpdGF0aW9uSWQpXG4gICAgICAuZXEoJ2ludml0ZWVfaWQnLCB1c2VyLmlkKVxuXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFjY2VwdGluZyBpbnZpdGF0aW9uOicsIGVycm9yKVxuICAgIHJldHVybiB7IGVycm9yLCBzdWNjZXNzOiBmYWxzZSB9XG4gIH1cbn1cblxuLyoqXG4gKiBEZWNsaW5lIGdyb3VwIGdvYWwgaW52aXRhdGlvblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVjbGluZUdyb3VwR29hbEludml0YXRpb24oaW52aXRhdGlvbklkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxuICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCcpXG5cbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2dyb3VwX2dvYWxfaW52aXRhdGlvbnMnKVxuICAgICAgLnVwZGF0ZSh7XG4gICAgICAgIHN0YXR1czogJ2RlY2xpbmVkJyxcbiAgICAgICAgcmVzcG9uZGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH0pXG4gICAgICAuZXEoJ2lkJywgaW52aXRhdGlvbklkKVxuICAgICAgLmVxKCdpbnZpdGVlX2lkJywgdXNlci5pZClcblxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWNsaW5pbmcgaW52aXRhdGlvbjonLCBlcnJvcilcbiAgICByZXR1cm4geyBlcnJvciwgc3VjY2VzczogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IGdyb3VwIGdvYWwgbWVtYmVyc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0R3JvdXBHb2FsTWVtYmVycyhnb2FsSWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZ3JvdXBfZ29hbF9tZW1iZXJzJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICAqLFxuICAgICAgICBwcm9maWxlOnByb2ZpbGVzKGZpcnN0X25hbWUsIGxhc3RfbmFtZSwgdXNlcm5hbWUsIHByb2ZpbGVfcGljdHVyZV91cmwpXG4gICAgICBgKVxuICAgICAgLmVxKCdnb2FsX2lkJywgZ29hbElkKVxuICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IHRydWUgfSlcblxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICByZXR1cm4geyBkYXRhLCBzdWNjZXNzOiB0cnVlIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBtZW1iZXJzOicsIGVycm9yKVxuICAgIHJldHVybiB7IGVycm9yLCBzdWNjZXNzOiBmYWxzZSB9XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NpZ24gYWN0aXZpdHkgdG8gdXNlcihzKSAoZGVwcmVjYXRlZCAtIHVzZSB1cGRhdGVBY3Rpdml0eUFzc2lnbm1lbnQpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3NpZ25BY3Rpdml0eShcbiAgYWN0aXZpdHlJZDogc3RyaW5nLFxuICBhc3NpZ25tZW50OiB7IGFzc2lnbmVkVG8/OiBzdHJpbmc7IGFzc2lnbmVkVG9BbGw6IGJvb2xlYW4gfVxuKSB7XG4gIHJldHVybiB1cGRhdGVBY3Rpdml0eUFzc2lnbm1lbnQoYWN0aXZpdHlJZCwgYXNzaWdubWVudClcbn1cblxuLyoqXG4gKiBDb21wbGV0ZSBhY3Rpdml0eSBmb3IgY3VycmVudCB1c2VyXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb21wbGV0ZUFjdGl2aXR5KFxuICBhY3Rpdml0eUlkOiBzdHJpbmcsXG4gIGdvYWxJZDogc3RyaW5nLFxuICBub3Rlcz86IHN0cmluZ1xuKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcbiAgICBpZiAoIXVzZXIpIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhlbnRpY2F0ZWQnKVxuXG4gICAgLy8gQ2hlY2sgaWYgYWN0aXZpdHkgaXMgYXNzaWduZWQgdG8gdGhpcyB1c2VyXG4gICAgY29uc3QgeyBkYXRhOiBhY3Rpdml0eSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdnb2FsX2FjdGl2aXRpZXMnKVxuICAgICAgLnNlbGVjdCgnYXNzaWduZWRfdG8sIGFzc2lnbmVkX3RvX2FsbCwgYXNzaWduZWRfbWVtYmVycywgdGl0bGUnKVxuICAgICAgLmVxKCdpZCcsIGFjdGl2aXR5SWQpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGlmICghYWN0aXZpdHkpIHRocm93IG5ldyBFcnJvcignQWN0aXZpdHkgbm90IGZvdW5kJylcblxuICAgIC8vIFZlcmlmeSB1c2VyIGNhbiBjb21wbGV0ZSB0aGlzIGFjdGl2aXR5XG4gICAgY29uc3QgY2FuQ29tcGxldGUgPSBhY3Rpdml0eS5hc3NpZ25lZF90b19hbGwgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgIGFjdGl2aXR5LmFzc2lnbmVkX3RvID09PSB1c2VyLmlkIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAoYWN0aXZpdHkuYXNzaWduZWRfbWVtYmVycyAmJiBhY3Rpdml0eS5hc3NpZ25lZF9tZW1iZXJzLmluY2x1ZGVzKHVzZXIuaWQpKVxuICAgIFxuICAgIGlmICghY2FuQ29tcGxldGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBub3QgYXNzaWduZWQgdG8gdGhpcyBhY3Rpdml0eScpXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBjb21wbGV0ZWQgYnkgdGhpcyB1c2VyXG4gICAgY29uc3QgeyBkYXRhOiBleGlzdGluZ0NvbXBsZXRpb24gfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYWN0aXZpdHlfY29tcGxldGlvbnMnKVxuICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgLmVxKCdhY3Rpdml0eV9pZCcsIGFjdGl2aXR5SWQpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICBpZiAoZXhpc3RpbmdDb21wbGV0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGl2aXR5IGFscmVhZHkgY29tcGxldGVkIGJ5IHlvdScpXG4gICAgfVxuXG4gICAgLy8gSW5zZXJ0IGNvbXBsZXRpb24gcmVjb3JkXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdhY3Rpdml0eV9jb21wbGV0aW9ucycpXG4gICAgICAuaW5zZXJ0KHtcbiAgICAgICAgYWN0aXZpdHlfaWQ6IGFjdGl2aXR5SWQsXG4gICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgIGdvYWxfaWQ6IGdvYWxJZCxcbiAgICAgICAgbm90ZXNcbiAgICAgIH0pXG5cbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAvLyBOb3RpZnkgb3RoZXIgZ3JvdXAgbWVtYmVyc1xuICAgIGNvbnN0IHsgZGF0YTogbWVtYmVycyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdncm91cF9nb2FsX21lbWJlcnMnKVxuICAgICAgLnNlbGVjdCgndXNlcl9pZCcpXG4gICAgICAuZXEoJ2dvYWxfaWQnLCBnb2FsSWQpXG4gICAgICAuZXEoJ3N0YXR1cycsICdhY2NlcHRlZCcpXG4gICAgICAubmVxKCd1c2VyX2lkJywgdXNlci5pZClcblxuICAgIGlmIChtZW1iZXJzICYmIG1lbWJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgeyBkYXRhOiB1c2VyUHJvZmlsZSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgLnNlbGVjdCgnZmlyc3RfbmFtZSwgbGFzdF9uYW1lLCB1c2VybmFtZScpXG4gICAgICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgY29uc3QgdXNlck5hbWUgPSB1c2VyUHJvZmlsZSBcbiAgICAgICAgPyBgJHt1c2VyUHJvZmlsZS5maXJzdF9uYW1lfSAke3VzZXJQcm9maWxlLmxhc3RfbmFtZX1gLnRyaW0oKSB8fCB1c2VyUHJvZmlsZS51c2VybmFtZVxuICAgICAgICA6ICdTb21lb25lJ1xuXG4gICAgICBjb25zdCBub3RpZmljYXRpb25zID0gbWVtYmVycy5tYXAobWVtYmVyID0+ICh7XG4gICAgICAgIHVzZXJfaWQ6IG1lbWJlci51c2VyX2lkLFxuICAgICAgICB0eXBlOiAnYWN0aXZpdHlfY29tcGxldGVkJyxcbiAgICAgICAgdGl0bGU6ICdBY3Rpdml0eSBDb21wbGV0ZWQhIPCfjoknLFxuICAgICAgICBtZXNzYWdlOiBgJHt1c2VyTmFtZX0gY29tcGxldGVkOiBcIiR7YWN0aXZpdHkudGl0bGV9XCJgLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgYWN0aXZpdHlfaWQ6IGFjdGl2aXR5SWQsXG4gICAgICAgICAgZ29hbF9pZDogZ29hbElkLFxuICAgICAgICAgIGNvbXBsZXRlZF9ieTogdXNlci5pZCxcbiAgICAgICAgICBjb21wbGV0ZWRfYnlfbmFtZTogdXNlck5hbWVcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZDogZmFsc2VcbiAgICAgIH0pKVxuXG4gICAgICBhd2FpdCBzdXBhYmFzZS5mcm9tKCdub3RpZmljYXRpb25zJykuaW5zZXJ0KG5vdGlmaWNhdGlvbnMpXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY29tcGxldGluZyBhY3Rpdml0eTonLCBlcnJvcilcbiAgICByZXR1cm4geyBlcnJvciwgc3VjY2VzczogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogVW5jb21wbGV0ZSBhY3Rpdml0eSBmb3IgY3VycmVudCB1c2VyIChyZW1vdmUgY29tcGxldGlvbilcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVuY29tcGxldGVBY3Rpdml0eShhY3Rpdml0eUlkOiBzdHJpbmcsIGdvYWxJZDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcbiAgICBpZiAoIXVzZXIpIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhlbnRpY2F0ZWQnKVxuXG4gICAgLy8gQ2hlY2sgaWYgdXNlciBjYW4gZWRpdCB0aGlzIGFjdGl2aXR5XG4gICAgY29uc3QgY2FuRWRpdCA9IGF3YWl0IGNhblVzZXJFZGl0QWN0aXZpdHkoYWN0aXZpdHlJZCwgdXNlci5pZClcbiAgICBpZiAoIWNhbkVkaXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCB1bmNvbXBsZXRlIHRoaXMgYWN0aXZpdHknKVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBjb21wbGV0aW9uIHJlY29yZFxuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYWN0aXZpdHlfY29tcGxldGlvbnMnKVxuICAgICAgLmRlbGV0ZSgpXG4gICAgICAuZXEoJ2FjdGl2aXR5X2lkJywgYWN0aXZpdHlJZClcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG5cbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdW5jb21wbGV0aW5nIGFjdGl2aXR5OicsIGVycm9yKVxuICAgIHJldHVybiB7IGVycm9yLCBzdWNjZXNzOiBmYWxzZSB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYWN0aXZpdHkgY29tcGxldGlvbiBzdGF0dXMgZm9yIGdyb3VwIGdvYWxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFjdGl2aXR5Q29tcGxldGlvbnMoYWN0aXZpdHlJZDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdhY3Rpdml0eV9jb21wbGV0aW9ucycpXG4gICAgICAuc2VsZWN0KGBcbiAgICAgICAgKixcbiAgICAgICAgdXNlcjpwcm9maWxlcyhmaXJzdF9uYW1lLCBsYXN0X25hbWUsIHVzZXJuYW1lLCBwcm9maWxlX3BpY3R1cmVfdXJsKVxuICAgICAgYClcbiAgICAgIC5lcSgnYWN0aXZpdHlfaWQnLCBhY3Rpdml0eUlkKVxuICAgICAgLm9yZGVyKCdjb21wbGV0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICByZXR1cm4geyBkYXRhLCBzdWNjZXNzOiB0cnVlIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjb21wbGV0aW9uczonLCBlcnJvcilcbiAgICByZXR1cm4geyBlcnJvciwgc3VjY2VzczogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdXNlciBjYW4gdXBkYXRlIGFjdGl2aXR5IChkZXByZWNhdGVkIC0gdXNlIGNhblVzZXJFZGl0QWN0aXZpdHkpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYW5Vc2VyVXBkYXRlQWN0aXZpdHkoYWN0aXZpdHlJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZykge1xuICByZXR1cm4gY2FuVXNlckVkaXRBY3Rpdml0eShhY3Rpdml0eUlkLCB1c2VySWQpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdXNlciBpcyBhZG1pbiAob3duZXIpIG9mIGEgZ3JvdXAgZ29hbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNHcm91cEdvYWxBZG1pbihnb2FsSWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdHJ5IHtcbiAgICAvLyBDaGVjayBpZiB1c2VyIGlzIHRoZSBnb2FsIG93bmVyXG4gICAgY29uc3QgeyBkYXRhOiBnb2FsIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2dvYWxzJylcbiAgICAgIC5zZWxlY3QoJ3VzZXJfaWQsIGlzX2dyb3VwX2dvYWwnKVxuICAgICAgLmVxKCdpZCcsIGdvYWxJZClcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgaWYgKCFnb2FsKSByZXR1cm4gZmFsc2VcbiAgICBcbiAgICAvLyBGb3IgZ3JvdXAgZ29hbHMsIGNoZWNrIGlmIHVzZXIgaXMgdGhlIG93bmVyXG4gICAgaWYgKGdvYWwuaXNfZ3JvdXBfZ29hbCkge1xuICAgICAgcmV0dXJuIGdvYWwudXNlcl9pZCA9PT0gdXNlcklkXG4gICAgfVxuICAgIFxuICAgIC8vIEZvciByZWd1bGFyIGdvYWxzLCBvbmx5IG93bmVyIGNhbiBtYW5hZ2VcbiAgICByZXR1cm4gZ29hbC51c2VyX2lkID09PSB1c2VySWRcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBhZG1pbiBwZXJtaXNzaW9uczonLCBlcnJvcilcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHVzZXIgY2FuIGVkaXQgYSBzcGVjaWZpYyBhY3Rpdml0eVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FuVXNlckVkaXRBY3Rpdml0eShhY3Rpdml0eUlkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhOiBhY3Rpdml0eSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdnb2FsX2FjdGl2aXRpZXMnKVxuICAgICAgLnNlbGVjdCgnYXNzaWduZWRfdG8sIGFzc2lnbmVkX3RvX2FsbCwgYXNzaWduZWRfbWVtYmVycywgZ29hbF9pZCcpXG4gICAgICAuZXEoJ2lkJywgYWN0aXZpdHlJZClcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgaWYgKCFhY3Rpdml0eSkgcmV0dXJuIGZhbHNlXG5cbiAgICAvLyBDaGVjayBpZiB1c2VyIGlzIGdvYWwgYWRtaW4gZmlyc3RcbiAgICBjb25zdCBpc0FkbWluID0gYXdhaXQgaXNHcm91cEdvYWxBZG1pbihhY3Rpdml0eS5nb2FsX2lkLCB1c2VySWQpXG4gICAgaWYgKGlzQWRtaW4pIHJldHVybiB0cnVlXG5cbiAgICAvLyBDaGVjayBpZiBhY3Rpdml0eSBpcyBhc3NpZ25lZCB0byB0aGlzIHVzZXJcbiAgICBpZiAoYWN0aXZpdHkuYXNzaWduZWRfdG9fYWxsKSByZXR1cm4gdHJ1ZVxuICAgIGlmIChhY3Rpdml0eS5hc3NpZ25lZF90byA9PT0gdXNlcklkKSByZXR1cm4gdHJ1ZVxuICAgIGlmIChhY3Rpdml0eS5hc3NpZ25lZF9tZW1iZXJzICYmIGFjdGl2aXR5LmFzc2lnbmVkX21lbWJlcnMuaW5jbHVkZXModXNlcklkKSkgcmV0dXJuIHRydWVcblxuICAgIHJldHVybiBmYWxzZVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIGFjdGl2aXR5IGVkaXQgcGVybWlzc2lvbnM6JywgZXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgZGV0YWlsZWQgZ3JvdXAgZ29hbCB3aXRoIG1lbWJlcnMgYW5kIGFjdGl2aXRpZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEdyb3VwR29hbERldGFpbHMoZ29hbElkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICAvLyBHZXQgZ29hbCBkZXRhaWxzXG4gICAgY29uc3QgeyBkYXRhOiBnb2FsLCBlcnJvcjogZ29hbEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2dvYWxzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdpZCcsIGdvYWxJZClcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgaWYgKGdvYWxFcnJvcikgdGhyb3cgZ29hbEVycm9yXG5cbiAgICAvLyBHZXQgbWVtYmVyc1xuICAgIGNvbnN0IHsgZGF0YTogbWVtYmVycywgZXJyb3I6IG1lbWJlcnNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdncm91cF9nb2FsX21lbWJlcnMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgICosXG4gICAgICAgIHByb2ZpbGU6cHJvZmlsZXMoZmlyc3RfbmFtZSwgbGFzdF9uYW1lLCB1c2VybmFtZSwgcHJvZmlsZV9waWN0dXJlX3VybClcbiAgICAgIGApXG4gICAgICAuZXEoJ2dvYWxfaWQnLCBnb2FsSWQpXG4gICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxuXG4gICAgaWYgKG1lbWJlcnNFcnJvcikgdGhyb3cgbWVtYmVyc0Vycm9yXG5cbiAgICAvLyBHZXQgYWN0aXZpdGllcyB3aXRoIGFzc2lnbm1lbnRzXG4gICAgY29uc3QgeyBkYXRhOiBhY3Rpdml0aWVzLCBlcnJvcjogYWN0aXZpdGllc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2dvYWxfYWN0aXZpdGllcycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgnZ29hbF9pZCcsIGdvYWxJZClcbiAgICAgIC5vcmRlcignb3JkZXJfaW5kZXgnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxuXG4gICAgaWYgKGFjdGl2aXRpZXNFcnJvcikgdGhyb3cgYWN0aXZpdGllc0Vycm9yXG5cbiAgICAvLyBHZXQgYWN0aXZpdHkgY29tcGxldGlvbnNcbiAgICBjb25zdCB7IGRhdGE6IGNvbXBsZXRpb25zLCBlcnJvcjogY29tcGxldGlvbnNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdhY3Rpdml0eV9jb21wbGV0aW9ucycpXG4gICAgICAuc2VsZWN0KGBcbiAgICAgICAgKixcbiAgICAgICAgdXNlcjpwcm9maWxlcyhmaXJzdF9uYW1lLCBsYXN0X25hbWUsIHVzZXJuYW1lLCBwcm9maWxlX3BpY3R1cmVfdXJsKVxuICAgICAgYClcbiAgICAgIC5lcSgnZ29hbF9pZCcsIGdvYWxJZClcbiAgICAgIC5vcmRlcignY29tcGxldGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICBpZiAoY29tcGxldGlvbnNFcnJvcikgdGhyb3cgY29tcGxldGlvbnNFcnJvclxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZ29hbCxcbiAgICAgICAgbWVtYmVyczogbWVtYmVycyB8fCBbXSxcbiAgICAgICAgYWN0aXZpdGllczogYWN0aXZpdGllcyB8fCBbXSxcbiAgICAgICAgY29tcGxldGlvbnM6IGNvbXBsZXRpb25zIHx8IFtdXG4gICAgICB9LFxuICAgICAgc3VjY2VzczogdHJ1ZVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBncm91cCBnb2FsIGRldGFpbHM6JywgZXJyb3IpXG4gICAgcmV0dXJuIHsgZXJyb3IsIHN1Y2Nlc3M6IGZhbHNlIH1cbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSBhY3Rpdml0eSBhc3NpZ25tZW50IChhZG1pbiBvbmx5KVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlQWN0aXZpdHlBc3NpZ25tZW50KFxuICBhY3Rpdml0eUlkOiBzdHJpbmcsXG4gIGFzc2lnbm1lbnQ6IHsgYXNzaWduZWRUbz86IHN0cmluZzsgYXNzaWduZWRUb0FsbDogYm9vbGVhbjsgYXNzaWduZWRNZW1iZXJzPzogc3RyaW5nW10gfVxuKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcbiAgICBpZiAoIXVzZXIpIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhlbnRpY2F0ZWQnKVxuXG4gICAgLy8gR2V0IGFjdGl2aXR5IHRvIGNoZWNrIHBlcm1pc3Npb25zXG4gICAgY29uc3QgeyBkYXRhOiBhY3Rpdml0eSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdnb2FsX2FjdGl2aXRpZXMnKVxuICAgICAgLnNlbGVjdCgnZ29hbF9pZCcpXG4gICAgICAuZXEoJ2lkJywgYWN0aXZpdHlJZClcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgaWYgKCFhY3Rpdml0eSkgdGhyb3cgbmV3IEVycm9yKCdBY3Rpdml0eSBub3QgZm91bmQnKVxuXG4gICAgLy8gQ2hlY2sgaWYgdXNlciBpcyBhZG1pblxuICAgIGNvbnN0IGlzQWRtaW4gPSBhd2FpdCBpc0dyb3VwR29hbEFkbWluKGFjdGl2aXR5LmdvYWxfaWQsIHVzZXIuaWQpXG4gICAgaWYgKCFpc0FkbWluKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgYWRtaW5zIGNhbiB1cGRhdGUgYWN0aXZpdHkgYXNzaWdubWVudHMnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZ29hbF9hY3Rpdml0aWVzJylcbiAgICAgIC51cGRhdGUoe1xuICAgICAgICBhc3NpZ25lZF90bzogYXNzaWdubWVudC5hc3NpZ25lZFRvIHx8IG51bGwsXG4gICAgICAgIGFzc2lnbmVkX3RvX2FsbDogYXNzaWdubWVudC5hc3NpZ25lZFRvQWxsLFxuICAgICAgICBhc3NpZ25lZF9tZW1iZXJzOiBhc3NpZ25tZW50LmFzc2lnbmVkTWVtYmVycyB8fCBudWxsLFxuICAgICAgICBhY3Rpdml0eV90eXBlOiBhc3NpZ25tZW50LmFzc2lnbmVkVG9BbGwgPyAnY29sbGFib3JhdGl2ZScgOiAoYXNzaWdubWVudC5hc3NpZ25lZE1lbWJlcnM/Lmxlbmd0aCA/ICdtdWx0aV9tZW1iZXInIDogJ2luZGl2aWR1YWwnKVxuICAgICAgfSlcbiAgICAgIC5lcSgnaWQnLCBhY3Rpdml0eUlkKVxuXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgYWN0aXZpdHkgYXNzaWdubWVudDonLCBlcnJvcilcbiAgICByZXR1cm4geyBlcnJvciwgc3VjY2VzczogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogRGVsZXRlIGdyb3VwIGdvYWwgKGFkbWluIG9ubHkpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVHcm91cEdvYWwoZ29hbElkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxuICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCcpXG5cbiAgICAvLyBDaGVjayBpZiB1c2VyIGlzIGFkbWluXG4gICAgY29uc3QgaXNBZG1pbiA9IGF3YWl0IGlzR3JvdXBHb2FsQWRtaW4oZ29hbElkLCB1c2VyLmlkKVxuICAgIGlmICghaXNBZG1pbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IHRoZSBnb2FsIGFkbWluIGNhbiBkZWxldGUgdGhpcyBnb2FsJylcbiAgICB9XG5cbiAgICAvLyBHZXQgZ29hbCBkZXRhaWxzIGZvciBub3RpZmljYXRpb25zXG4gICAgY29uc3QgeyBkYXRhOiBnb2FsIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2dvYWxzJylcbiAgICAgIC5zZWxlY3QoJ3RpdGxlJylcbiAgICAgIC5lcSgnaWQnLCBnb2FsSWQpXG4gICAgICAuc2luZ2xlKClcblxuICAgIC8vIEdldCBhbGwgbWVtYmVycyB0byBub3RpZnkgdGhlbVxuICAgIGNvbnN0IHsgZGF0YTogbWVtYmVycyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdncm91cF9nb2FsX21lbWJlcnMnKVxuICAgICAgLnNlbGVjdCgndXNlcl9pZCwgcHJvZmlsZTpwcm9maWxlcyhmaXJzdF9uYW1lLCBsYXN0X25hbWUpJylcbiAgICAgIC5lcSgnZ29hbF9pZCcsIGdvYWxJZClcbiAgICAgIC5lcSgnc3RhdHVzJywgJ2FjY2VwdGVkJylcbiAgICAgIC5uZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKSAvLyBFeGNsdWRlIHRoZSBhZG1pblxuXG4gICAgLy8gRGVsZXRlIHRoZSBnb2FsIChjYXNjYWRlIHdpbGwgaGFuZGxlIHJlbGF0ZWQgcmVjb3JkcylcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2dvYWxzJylcbiAgICAgIC5kZWxldGUoKVxuICAgICAgLmVxKCdpZCcsIGdvYWxJZClcblxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgIC8vIE5vdGlmeSBhbGwgbWVtYmVycyBhYm91dCBnb2FsIGRlbGV0aW9uXG4gICAgaWYgKG1lbWJlcnMgJiYgbWVtYmVycy5sZW5ndGggPiAwICYmIGdvYWwpIHtcbiAgICAgIGNvbnN0IHsgZGF0YTogYWRtaW5Qcm9maWxlIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxuICAgICAgICAuc2VsZWN0KCdmaXJzdF9uYW1lLCBsYXN0X25hbWUsIHVzZXJuYW1lJylcbiAgICAgICAgLmVxKCdpZCcsIHVzZXIuaWQpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBjb25zdCBhZG1pbk5hbWUgPSBhZG1pblByb2ZpbGUgXG4gICAgICAgID8gYCR7YWRtaW5Qcm9maWxlLmZpcnN0X25hbWV9ICR7YWRtaW5Qcm9maWxlLmxhc3RfbmFtZX1gLnRyaW0oKSB8fCBhZG1pblByb2ZpbGUudXNlcm5hbWVcbiAgICAgICAgOiAnQWRtaW4nXG5cbiAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbnMgPSBtZW1iZXJzLm1hcChtZW1iZXIgPT4gKHtcbiAgICAgICAgdXNlcl9pZDogbWVtYmVyLnVzZXJfaWQsXG4gICAgICAgIHR5cGU6ICdnb2FsX2RlbGV0ZWQnLFxuICAgICAgICB0aXRsZTogJ0dyb3VwIEdvYWwgRGVsZXRlZCcsXG4gICAgICAgIG1lc3NhZ2U6IGAke2FkbWluTmFtZX0gZGVsZXRlZCB0aGUgZ3JvdXAgZ29hbDogXCIke2dvYWwudGl0bGV9XCJgLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZ29hbF9pZDogZ29hbElkLFxuICAgICAgICAgIGdvYWxfdGl0bGU6IGdvYWwudGl0bGUsXG4gICAgICAgICAgZGVsZXRlZF9ieTogdXNlci5pZCxcbiAgICAgICAgICBkZWxldGVkX2J5X25hbWU6IGFkbWluTmFtZVxuICAgICAgICB9LFxuICAgICAgICByZWFkOiBmYWxzZVxuICAgICAgfSkpXG5cbiAgICAgIGF3YWl0IHN1cGFiYXNlLmZyb20oJ25vdGlmaWNhdGlvbnMnKS5pbnNlcnQobm90aWZpY2F0aW9ucylcbiAgICB9XG5cbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBncm91cCBnb2FsOicsIGVycm9yKVxuICAgIHJldHVybiB7IGVycm9yLCBzdWNjZXNzOiBmYWxzZSB9XG4gIH1cbn1cblxuLyoqXG4gKiBVcGRhdGUgZ3JvdXAgZ29hbCAoYWRtaW4gb25seSlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUdyb3VwR29hbChnb2FsSWQ6IHN0cmluZywgdXBkYXRlczogYW55KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcbiAgICBpZiAoIXVzZXIpIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhlbnRpY2F0ZWQnKVxuXG4gICAgLy8gQ2hlY2sgaWYgdXNlciBpcyBhZG1pblxuICAgIGNvbnN0IGlzQWRtaW4gPSBhd2FpdCBpc0dyb3VwR29hbEFkbWluKGdvYWxJZCwgdXNlci5pZClcbiAgICBpZiAoIWlzQWRtaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSB0aGUgZ29hbCBhZG1pbiBjYW4gZWRpdCB0aGlzIGdvYWwnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZ29hbHMnKVxuICAgICAgLnVwZGF0ZSh1cGRhdGVzKVxuICAgICAgLmVxKCdpZCcsIGdvYWxJZClcblxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgIC8vIElmIHNpZ25pZmljYW50IGNoYW5nZXMsIG5vdGlmeSBtZW1iZXJzXG4gICAgaWYgKHVwZGF0ZXMudGl0bGUgfHwgdXBkYXRlcy5kZXNjcmlwdGlvbiB8fCB1cGRhdGVzLnRhcmdldF9kYXRlKSB7XG4gICAgICBjb25zdCB7IGRhdGE6IG1lbWJlcnMgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdncm91cF9nb2FsX21lbWJlcnMnKVxuICAgICAgICAuc2VsZWN0KCd1c2VyX2lkJylcbiAgICAgICAgLmVxKCdnb2FsX2lkJywgZ29hbElkKVxuICAgICAgICAuZXEoJ3N0YXR1cycsICdhY2NlcHRlZCcpXG4gICAgICAgIC5uZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuXG4gICAgICBpZiAobWVtYmVycyAmJiBtZW1iZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBhZG1pblByb2ZpbGUgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcbiAgICAgICAgICAuc2VsZWN0KCdmaXJzdF9uYW1lLCBsYXN0X25hbWUsIHVzZXJuYW1lJylcbiAgICAgICAgICAuZXEoJ2lkJywgdXNlci5pZClcbiAgICAgICAgICAuc2luZ2xlKClcblxuICAgICAgICBjb25zdCBhZG1pbk5hbWUgPSBhZG1pblByb2ZpbGUgXG4gICAgICAgICAgPyBgJHthZG1pblByb2ZpbGUuZmlyc3RfbmFtZX0gJHthZG1pblByb2ZpbGUubGFzdF9uYW1lfWAudHJpbSgpIHx8IGFkbWluUHJvZmlsZS51c2VybmFtZVxuICAgICAgICAgIDogJ0FkbWluJ1xuXG4gICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbnMgPSBtZW1iZXJzLm1hcChtZW1iZXIgPT4gKHtcbiAgICAgICAgICB1c2VyX2lkOiBtZW1iZXIudXNlcl9pZCxcbiAgICAgICAgICB0eXBlOiAnZ29hbF91cGRhdGVkJyxcbiAgICAgICAgICB0aXRsZTogJ0dyb3VwIEdvYWwgVXBkYXRlZCcsXG4gICAgICAgICAgbWVzc2FnZTogYCR7YWRtaW5OYW1lfSB1cGRhdGVkIHRoZSBncm91cCBnb2FsIGRldGFpbHNgLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGdvYWxfaWQ6IGdvYWxJZCxcbiAgICAgICAgICAgIHVwZGF0ZWRfYnk6IHVzZXIuaWQsXG4gICAgICAgICAgICB1cGRhdGVkX2J5X25hbWU6IGFkbWluTmFtZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVhZDogZmFsc2VcbiAgICAgICAgfSkpXG5cbiAgICAgICAgYXdhaXQgc3VwYWJhc2UuZnJvbSgnbm90aWZpY2F0aW9ucycpLmluc2VydChub3RpZmljYXRpb25zKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGdyb3VwIGdvYWw6JywgZXJyb3IpXG4gICAgcmV0dXJuIHsgZXJyb3IsIHN1Y2Nlc3M6IGZhbHNlIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCBncm91cCBnb2FsIHByb2dyZXNzIHdpdGggbWVtYmVyIHN0YXRzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRHcm91cEdvYWxQcm9ncmVzcyhnb2FsSWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIC8vIEdldCBhbGwgYWN0aXZpdGllc1xuICAgIGNvbnN0IHsgZGF0YTogYWN0aXZpdGllcyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdnb2FsX2FjdGl2aXRpZXMnKVxuICAgICAgLnNlbGVjdCgnaWQsIHRpdGxlLCBhc3NpZ25lZF90bywgYXNzaWduZWRfdG9fYWxsLCBjb21wbGV0ZWQnKVxuICAgICAgLmVxKCdnb2FsX2lkJywgZ29hbElkKVxuXG4gICAgaWYgKCFhY3Rpdml0aWVzKSByZXR1cm4geyBkYXRhOiBudWxsLCBzdWNjZXNzOiBmYWxzZSB9XG5cbiAgICAvLyBHZXQgYWxsIGFjY2VwdGVkIG1lbWJlcnNcbiAgICBjb25zdCB7IGRhdGE6IG1lbWJlcnMgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZ3JvdXBfZ29hbF9tZW1iZXJzJylcbiAgICAgIC5zZWxlY3QoJ3VzZXJfaWQsIHByb2ZpbGU6cHJvZmlsZXMoZmlyc3RfbmFtZSwgbGFzdF9uYW1lLCB1c2VybmFtZSknKVxuICAgICAgLmVxKCdnb2FsX2lkJywgZ29hbElkKVxuICAgICAgLmVxKCdzdGF0dXMnLCAnYWNjZXB0ZWQnKVxuXG4gICAgLy8gR2V0IGFsbCBjb21wbGV0aW9uc1xuICAgIGNvbnN0IHsgZGF0YTogY29tcGxldGlvbnMgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYWN0aXZpdHlfY29tcGxldGlvbnMnKVxuICAgICAgLnNlbGVjdCgnYWN0aXZpdHlfaWQsIHVzZXJfaWQnKVxuICAgICAgLmVxKCdnb2FsX2lkJywgZ29hbElkKVxuXG4gICAgY29uc3QgbWVtYmVyUHJvZ3Jlc3MgPSBtZW1iZXJzPy5tYXAobWVtYmVyID0+IHtcbiAgICAgIGNvbnN0IGFzc2lnbmVkQWN0aXZpdGllcyA9IGFjdGl2aXRpZXMuZmlsdGVyKFxuICAgICAgICBhID0+IGEuYXNzaWduZWRfdG9fYWxsIHx8IGEuYXNzaWduZWRfdG8gPT09IG1lbWJlci51c2VyX2lkXG4gICAgICApXG4gICAgICBjb25zdCBjb21wbGV0ZWRBY3Rpdml0aWVzID0gYXNzaWduZWRBY3Rpdml0aWVzLmZpbHRlcihhID0+XG4gICAgICAgIGNvbXBsZXRpb25zPy5zb21lKGMgPT4gYy5hY3Rpdml0eV9pZCA9PT0gYS5pZCAmJiBjLnVzZXJfaWQgPT09IG1lbWJlci51c2VyX2lkKVxuICAgICAgKVxuXG4gICAgICBjb25zdCBwcm9maWxlID0gbWVtYmVyLnByb2ZpbGUgYXMgYW55XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1c2VyX2lkOiBtZW1iZXIudXNlcl9pZCxcbiAgICAgICAgbmFtZTogcHJvZmlsZSA/IGAke3Byb2ZpbGUuZmlyc3RfbmFtZSB8fCAnJ30gJHtwcm9maWxlLmxhc3RfbmFtZSB8fCAnJ31gLnRyaW0oKSA6ICdVbmtub3duJyxcbiAgICAgICAgYXNzaWduZWQ6IGFzc2lnbmVkQWN0aXZpdGllcy5sZW5ndGgsXG4gICAgICAgIGNvbXBsZXRlZDogY29tcGxldGVkQWN0aXZpdGllcy5sZW5ndGgsXG4gICAgICAgIHByb2dyZXNzOiBhc3NpZ25lZEFjdGl2aXRpZXMubGVuZ3RoID4gMFxuICAgICAgICAgID8gTWF0aC5yb3VuZCgoY29tcGxldGVkQWN0aXZpdGllcy5sZW5ndGggLyBhc3NpZ25lZEFjdGl2aXRpZXMubGVuZ3RoKSAqIDEwMClcbiAgICAgICAgICA6IDBcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gQ2FsY3VsYXRlIG92ZXJhbGwgcHJvZ3Jlc3NcbiAgICBjb25zdCB0b3RhbEFzc2lnbmVkQWN0aXZpdGllcyA9IG1lbWJlclByb2dyZXNzPy5yZWR1Y2UoKHN1bSwgbWVtYmVyKSA9PiBzdW0gKyBtZW1iZXIuYXNzaWduZWQsIDApIHx8IDBcbiAgICBjb25zdCB0b3RhbENvbXBsZXRlZEFjdGl2aXRpZXMgPSBtZW1iZXJQcm9ncmVzcz8ucmVkdWNlKChzdW0sIG1lbWJlcikgPT4gc3VtICsgbWVtYmVyLmNvbXBsZXRlZCwgMCkgfHwgMFxuICAgIGNvbnN0IG92ZXJhbGxQcm9ncmVzcyA9IHRvdGFsQXNzaWduZWRBY3Rpdml0aWVzID4gMCBcbiAgICAgID8gTWF0aC5yb3VuZCgodG90YWxDb21wbGV0ZWRBY3Rpdml0aWVzIC8gdG90YWxBc3NpZ25lZEFjdGl2aXRpZXMpICogMTAwKVxuICAgICAgOiAwXG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YToge1xuICAgICAgICB0b3RhbEFjdGl2aXRpZXM6IGFjdGl2aXRpZXMubGVuZ3RoLFxuICAgICAgICBjb21wbGV0ZWRBY3Rpdml0aWVzOiBhY3Rpdml0aWVzLmZpbHRlcihhID0+IGEuY29tcGxldGVkKS5sZW5ndGgsXG4gICAgICAgIG92ZXJhbGxQcm9ncmVzcyxcbiAgICAgICAgbWVtYmVyUHJvZ3Jlc3NcbiAgICAgIH0sXG4gICAgICBzdWNjZXNzOiB0cnVlXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByb2dyZXNzOicsIGVycm9yKVxuICAgIHJldHVybiB7IGVycm9yLCBzdWNjZXNzOiBmYWxzZSB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYWN0aXZpdHkgcHJvZ3Jlc3MgZm9yIGEgc3BlY2lmaWMgYWN0aXZpdHlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFjdGl2aXR5UHJvZ3Jlc3MoYWN0aXZpdHlJZDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgLy8gR2V0IGFjdGl2aXR5IGRldGFpbHNcbiAgICBjb25zdCB7IGRhdGE6IGFjdGl2aXR5IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2dvYWxfYWN0aXZpdGllcycpXG4gICAgICAuc2VsZWN0KCcqLCBnb2FsX2lkJylcbiAgICAgIC5lcSgnaWQnLCBhY3Rpdml0eUlkKVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICBpZiAoIWFjdGl2aXR5KSB0aHJvdyBuZXcgRXJyb3IoJ0FjdGl2aXR5IG5vdCBmb3VuZCcpXG5cbiAgICAvLyBHZXQgYXNzaWduZWQgbWVtYmVyc1xuICAgIGxldCBhc3NpZ25lZE1lbWJlcnMgPSBbXVxuICAgIGlmIChhY3Rpdml0eS5hc3NpZ25lZF90b19hbGwpIHtcbiAgICAgIGNvbnN0IHsgZGF0YTogYWxsTWVtYmVycyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2dyb3VwX2dvYWxfbWVtYmVycycpXG4gICAgICAgIC5zZWxlY3QoJ3VzZXJfaWQsIHByb2ZpbGU6cHJvZmlsZXMoZmlyc3RfbmFtZSwgbGFzdF9uYW1lLCB1c2VybmFtZSwgcHJvZmlsZV9waWN0dXJlX3VybCknKVxuICAgICAgICAuZXEoJ2dvYWxfaWQnLCBhY3Rpdml0eS5nb2FsX2lkKVxuICAgICAgICAuZXEoJ3N0YXR1cycsICdhY2NlcHRlZCcpXG4gICAgICBhc3NpZ25lZE1lbWJlcnMgPSBhbGxNZW1iZXJzIHx8IFtdXG4gICAgfSBlbHNlIGlmIChhY3Rpdml0eS5hc3NpZ25lZF9tZW1iZXJzICYmIGFjdGl2aXR5LmFzc2lnbmVkX21lbWJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgeyBkYXRhOiBtdWx0aXBsZU1lbWJlcnMgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgIC5zZWxlY3QoJ2lkLCBmaXJzdF9uYW1lLCBsYXN0X25hbWUsIHVzZXJuYW1lLCBwcm9maWxlX3BpY3R1cmVfdXJsJylcbiAgICAgICAgLmluKCdpZCcsIGFjdGl2aXR5LmFzc2lnbmVkX21lbWJlcnMpXG4gICAgICBpZiAobXVsdGlwbGVNZW1iZXJzKSB7XG4gICAgICAgIGFzc2lnbmVkTWVtYmVycyA9IG11bHRpcGxlTWVtYmVycy5tYXAobWVtYmVyID0+ICh7IHVzZXJfaWQ6IG1lbWJlci5pZCwgcHJvZmlsZTogbWVtYmVyIH0pKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWN0aXZpdHkuYXNzaWduZWRfdG8pIHtcbiAgICAgIGNvbnN0IHsgZGF0YTogc3BlY2lmaWNNZW1iZXIgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwcm9maWxlcycpXG4gICAgICAgIC5zZWxlY3QoJ2lkLCBmaXJzdF9uYW1lLCBsYXN0X25hbWUsIHVzZXJuYW1lLCBwcm9maWxlX3BpY3R1cmVfdXJsJylcbiAgICAgICAgLmVxKCdpZCcsIGFjdGl2aXR5LmFzc2lnbmVkX3RvKVxuICAgICAgICAuc2luZ2xlKClcbiAgICAgIGlmIChzcGVjaWZpY01lbWJlcikge1xuICAgICAgICBhc3NpZ25lZE1lbWJlcnMgPSBbeyB1c2VyX2lkOiBzcGVjaWZpY01lbWJlci5pZCwgcHJvZmlsZTogc3BlY2lmaWNNZW1iZXIgfV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXQgY29tcGxldGlvbnNcbiAgICBjb25zdCB7IGRhdGE6IGNvbXBsZXRpb25zIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2FjdGl2aXR5X2NvbXBsZXRpb25zJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICAqLFxuICAgICAgICB1c2VyOnByb2ZpbGVzKGZpcnN0X25hbWUsIGxhc3RfbmFtZSwgdXNlcm5hbWUsIHByb2ZpbGVfcGljdHVyZV91cmwpXG4gICAgICBgKVxuICAgICAgLmVxKCdhY3Rpdml0eV9pZCcsIGFjdGl2aXR5SWQpXG4gICAgICAub3JkZXIoJ2NvbXBsZXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gICAgY29uc3QgY29tcGxldGVkVXNlcklkcyA9IG5ldyBTZXQoY29tcGxldGlvbnM/Lm1hcChjID0+IGMudXNlcl9pZCkgfHwgW10pXG4gICAgY29uc3QgcHJvZ3Jlc3NQZXJjZW50YWdlID0gYXNzaWduZWRNZW1iZXJzLmxlbmd0aCA+IDAgXG4gICAgICA/IE1hdGgucm91bmQoKGNvbXBsZXRpb25zPy5sZW5ndGggfHwgMCkgLyBhc3NpZ25lZE1lbWJlcnMubGVuZ3RoICogMTAwKVxuICAgICAgOiAwXG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YToge1xuICAgICAgICBhY3Rpdml0eSxcbiAgICAgICAgYXNzaWduZWRNZW1iZXJzLFxuICAgICAgICBjb21wbGV0aW9uczogY29tcGxldGlvbnMgfHwgW10sXG4gICAgICAgIHByb2dyZXNzUGVyY2VudGFnZSxcbiAgICAgICAgY29tcGxldGVkQ291bnQ6IGNvbXBsZXRpb25zPy5sZW5ndGggfHwgMCxcbiAgICAgICAgdG90YWxBc3NpZ25lZDogYXNzaWduZWRNZW1iZXJzLmxlbmd0aFxuICAgICAgfSxcbiAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYWN0aXZpdHkgcHJvZ3Jlc3M6JywgZXJyb3IpXG4gICAgcmV0dXJuIHsgZXJyb3IsIHN1Y2Nlc3M6IGZhbHNlIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbInN1cGFiYXNlIiwiY3JlYXRlR3JvdXBHb2FsIiwiZ29hbERhdGEiLCJtZW1iZXJJZHMiLCJkYXRhIiwidXNlciIsImF1dGgiLCJnZXRVc2VyIiwiRXJyb3IiLCJnb2FsIiwiZXJyb3IiLCJnb2FsRXJyb3IiLCJmcm9tIiwiaW5zZXJ0IiwidXNlcl9pZCIsImlkIiwiaXNfZ3JvdXBfZ29hbCIsImdyb3VwX2dvYWxfc3RhdHVzIiwic2VsZWN0Iiwic2luZ2xlIiwibWVtYmVyRXJyb3IiLCJnb2FsX2lkIiwicm9sZSIsInN0YXR1cyIsImNhbl9lZGl0IiwiY29uc29sZSIsImludml0YXRpb25zIiwibWFwIiwibWVtYmVySWQiLCJpbnZpdGVyX2lkIiwiaW52aXRlZV9pZCIsIm1lc3NhZ2UiLCJ0aXRsZSIsImludml0ZUVycm9yIiwicHJvZmlsZSIsImVxIiwidXNlck5hbWUiLCJmaXJzdF9uYW1lIiwibGFzdF9uYW1lIiwidHJpbSIsInVzZXJuYW1lIiwibm90aWZpY2F0aW9ucyIsInR5cGUiLCJpbnZpdGF0aW9uX3R5cGUiLCJhY3Rpb25fcmVxdWlyZWQiLCJyZWFkIiwibm90aWZFcnJvciIsInN1Y2Nlc3MiLCJnZXRQZW5kaW5nSW52aXRhdGlvbnMiLCJvcmRlciIsImFzY2VuZGluZyIsImFjY2VwdEdyb3VwR29hbEludml0YXRpb24iLCJpbnZpdGF0aW9uSWQiLCJ1cGRhdGUiLCJyZXNwb25kZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJkZWNsaW5lR3JvdXBHb2FsSW52aXRhdGlvbiIsImdldEdyb3VwR29hbE1lbWJlcnMiLCJnb2FsSWQiLCJhc3NpZ25BY3Rpdml0eSIsImFjdGl2aXR5SWQiLCJhc3NpZ25tZW50IiwidXBkYXRlQWN0aXZpdHlBc3NpZ25tZW50IiwiY29tcGxldGVBY3Rpdml0eSIsIm5vdGVzIiwiYWN0aXZpdHkiLCJjYW5Db21wbGV0ZSIsImFzc2lnbmVkX3RvX2FsbCIsImFzc2lnbmVkX3RvIiwiYXNzaWduZWRfbWVtYmVycyIsImluY2x1ZGVzIiwiZXhpc3RpbmdDb21wbGV0aW9uIiwiYWN0aXZpdHlfaWQiLCJtZW1iZXJzIiwibmVxIiwibGVuZ3RoIiwidXNlclByb2ZpbGUiLCJtZW1iZXIiLCJjb21wbGV0ZWRfYnkiLCJjb21wbGV0ZWRfYnlfbmFtZSIsInVuY29tcGxldGVBY3Rpdml0eSIsImNhbkVkaXQiLCJjYW5Vc2VyRWRpdEFjdGl2aXR5IiwiZGVsZXRlIiwiZ2V0QWN0aXZpdHlDb21wbGV0aW9ucyIsImNhblVzZXJVcGRhdGVBY3Rpdml0eSIsInVzZXJJZCIsImlzR3JvdXBHb2FsQWRtaW4iLCJpc0FkbWluIiwiZ2V0R3JvdXBHb2FsRGV0YWlscyIsIm1lbWJlcnNFcnJvciIsImFjdGl2aXRpZXMiLCJhY3Rpdml0aWVzRXJyb3IiLCJjb21wbGV0aW9ucyIsImNvbXBsZXRpb25zRXJyb3IiLCJhc3NpZ25lZFRvIiwiYXNzaWduZWRUb0FsbCIsImFzc2lnbmVkTWVtYmVycyIsImFjdGl2aXR5X3R5cGUiLCJkZWxldGVHcm91cEdvYWwiLCJhZG1pblByb2ZpbGUiLCJhZG1pbk5hbWUiLCJnb2FsX3RpdGxlIiwiZGVsZXRlZF9ieSIsImRlbGV0ZWRfYnlfbmFtZSIsInVwZGF0ZUdyb3VwR29hbCIsInVwZGF0ZXMiLCJkZXNjcmlwdGlvbiIsInRhcmdldF9kYXRlIiwidXBkYXRlZF9ieSIsInVwZGF0ZWRfYnlfbmFtZSIsImdldEdyb3VwR29hbFByb2dyZXNzIiwibWVtYmVyUHJvZ3Jlc3MiLCJhc3NpZ25lZEFjdGl2aXRpZXMiLCJmaWx0ZXIiLCJhIiwiY29tcGxldGVkQWN0aXZpdGllcyIsInNvbWUiLCJjIiwibmFtZSIsImFzc2lnbmVkIiwiY29tcGxldGVkIiwicHJvZ3Jlc3MiLCJNYXRoIiwicm91bmQiLCJ0b3RhbEFzc2lnbmVkQWN0aXZpdGllcyIsInJlZHVjZSIsInN1bSIsInRvdGFsQ29tcGxldGVkQWN0aXZpdGllcyIsIm92ZXJhbGxQcm9ncmVzcyIsInRvdGFsQWN0aXZpdGllcyIsImdldEFjdGl2aXR5UHJvZ3Jlc3MiLCJhbGxNZW1iZXJzIiwibXVsdGlwbGVNZW1iZXJzIiwiaW4iLCJzcGVjaWZpY01lbWJlciIsImNvbXBsZXRlZFVzZXJJZHMiLCJTZXQiLCJwcm9ncmVzc1BlcmNlbnRhZ2UiLCJjb21wbGV0ZWRDb3VudCIsInRvdGFsQXNzaWduZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/group-goals.ts\n"));

/***/ })

});